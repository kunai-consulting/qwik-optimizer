---
phase: 06-imports-exports
plan: 04
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - optimizer/src/transform.rs
autonomous: true

must_haves:
  truths:
    - "Side-effect imports (import './styles.css') are preserved"
    - "Re-exports pass through unchanged"
    - "Polyfills and CSS load before application code that depends on them"
    - "Dynamic imports in QRLs generate correct lazy-loading code"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Side-effect and re-export handling"
      contains: "side_effect_imports"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "optimizer/src/import_clean_up.rs"
      via: "ImportCleanUp preserves side-effects"
      pattern: "specifiers.*None"
---

<objective>
Ensure side-effect imports and re-exports are handled correctly.

Purpose: Side-effect imports like `import './styles.css'` must be preserved (not cleaned up). Re-exports like `export { foo } from './other'` should pass through the transformation unchanged. These are edge cases that need verification and potentially fixing.

Output: Side-effect imports preserved, re-exports untouched.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-imports-exports/06-RESEARCH.md
@.planning/phases/06-imports-exports/06-02-SUMMARY.md
@optimizer/src/transform.rs
@optimizer/src/import_clean_up.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify side-effect import preservation</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Verify that side-effect imports are preserved by ImportCleanUp (read-only verification):

1. Review the current ImportCleanUp logic in import_clean_up.rs exit_statements (around line 103-133):
   ```rust
   Statement::ImportDeclaration(import) => {
       if let Some(specifiers) = &import.specifiers {
           // Process specifiers...
           false  // Remove the import (will be re-added if used)
       } else {
           true  // Keep side-effect imports (no specifiers)
       }
   }
   ```

2. This logic should already preserve side-effect imports. Verify by adding a test in transform.rs:
   ```rust
   #[test]
   fn test_side_effect_imports_preserved() {
       let source = r#"
           import './side-effect.js';
           import './styles.css';
           import { used } from './module';

           used();
       "#;

       // After cleanup, should have:
       // import './side-effect.js';
       // import './styles.css';
       // import { used } from './module';
   }
   ```

3. If the test fails, create a follow-up task - this task is verification only
  </action>
  <verify>`cargo test test_side_effect_imports_preserved` passes</verify>
  <done>Side-effect imports are preserved through transformation</done>
</task>

<task type="auto">
  <name>Task 2: Verify re-export handling</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Verify that re-exports pass through unchanged:

1. Re-exports have the form:
   - `export { foo } from './other'`
   - `export { foo as bar } from './other'`
   - `export * from './other'`

2. These should NOT be processed by QRL transformation - they're just passing through

3. Add test `test_reexports_unchanged`:
   ```rust
   #[test]
   fn test_reexports_unchanged() {
       let source = r#"
           import { component$ } from '@qwik.dev/core';

           export { foo } from './other';
           export { bar as baz } from './another';
           export * from './all';

           export const App = component$(() => <div>test</div>);
       "#;

       // Verify output preserves:
       // export { foo } from "./other";
       // export { bar as baz } from "./another";
       // export * from "./all";
   }
   ```

4. If re-exports are being modified incorrectly, add early return in export handlers

5. Re-exports have `source` field in ExportNamedDeclaration - use this to detect and skip
  </action>
  <verify>`cargo test test_reexports_unchanged` passes</verify>
  <done>Re-exports pass through transformation unchanged</done>
</task>

<task type="auto">
  <name>Task 3: Verify dynamic import generation (IMP-08)</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Verify that dynamic import generation for QRL lazy-loading is working correctly. This capability is already implemented in qrl.rs (lines 152-179) via `create_simple_import`, but needs explicit verification:

1. The QRL `into_arrow_function` method generates:
   ```rust
   let filename = format!("./{}.js", self.rel_path.file_name()...);
   statements.push(ast_builder.create_simple_import(filename.as_ref()));
   ```
   This creates: `() => import("./segment_file.js")`

2. Add test `test_dynamic_import_generation`:
   ```rust
   #[test]
   fn test_dynamic_import_generation() {
       let source = r#"
           import { component$ } from '@qwik.dev/core';

           export const App = component$(() => {
               return <div>Hello</div>;
           });
       "#;

       // Transform and verify output contains:
       // qrl(() => import("./test_qrl_..."), "App_component_...")
       // The arrow function with dynamic import is the lazy-loading mechanism
   }
   ```

3. Add test `test_dynamic_import_in_qrl`:
   ```rust
   #[test]
   fn test_dynamic_import_in_qrl() {
       let source = r#"
           import { component$ } from '@qwik.dev/core';

           export const App = component$(() => {
               const loadModule = async () => {
                   const mod = await import('./lazy-module');
                   return mod.default;
               };
               return <div onClick$={loadModule}>load</div>;
           });
       "#;

       // Dynamic imports inside QRL bodies should be preserved
       // The QRL wrapper adds its own dynamic import for lazy-loading
   }
   ```

This verifies IMP-08 (Dynamic import generation) is complete.
  </action>
  <verify>`cargo test test_dynamic_import` passes for both tests</verify>
  <done>Dynamic import generation verified working for QRL lazy-loading</done>
</task>

<task type="auto">
  <name>Task 4: Comprehensive import/export edge case tests</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add comprehensive tests for import/export edge cases:

1. Test `test_import_order_preserved`:
   ```rust
   #[test]
   fn test_import_order_preserved() {
       // Side-effect imports should maintain their relative order
       let source = r#"
           import './polyfill';
           import { component$ } from '@qwik.dev/core';
           import './styles.css';

           export const App = component$(() => <div>test</div>);
       "#;

       // Verify: polyfill before component$, styles.css after
       // Critical for polyfills that must load before app code
   }
   ```

2. Test `test_mixed_import_types`:
   ```rust
   #[test]
   fn test_mixed_import_types() {
       let source = r#"
           import { component$ } from '@qwik.dev/core';
           import Default from './default';
           import * as All from './namespace';
           import { named } from './named';

           export const App = component$(() => {
               return <div>{Default}{All.foo}{named}</div>;
           });
       "#;

       // Verify all import types work correctly
   }
   ```
  </action>
  <verify>`cargo test` passes for all new import/export tests</verify>
  <done>Comprehensive tests cover side-effects, re-exports, import types, and dynamic imports</done>
</task>

</tasks>

<verification>
1. `cargo build -p qwik-optimizer` compiles
2. `cargo test -p qwik-optimizer` passes (all tests)
3. Side-effect imports preserved in output
4. Re-exports unchanged in output
5. Dynamic imports generated correctly for QRL lazy-loading
6. Import order maintained for polyfills and CSS
</verification>

<success_criteria>
- Side-effect imports (`import './x'`) preserved after transformation
- Re-exports (`export { x } from './y'`) pass through unchanged
- Dynamic imports generated for QRL lazy-loading (IMP-08 verified)
- Import order maintained (polyfills load before dependent code)
- All import types (default, named, namespace) work in QRLs
- Dynamic imports inside QRLs work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-imports-exports/06-04-SUMMARY.md`
</output>
