---
phase: 06-imports-exports
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/transform.rs
  - optimizer/src/component/shared.rs
autonomous: true

must_haves:
  truths:
    - "All synthesized imports are emitted at module finalization"
    - "Unused imports are cleaned up after transformation"
    - "Import order: synthesized first, then original (cleaned)"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Module finalization with synthesized import emission"
      contains: "finalize_imports"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "optimizer/src/import_clean_up.rs"
      via: "ImportCleanUp::clean_up call"
      pattern: "ImportCleanUp::clean_up"
---

<objective>
Implement module finalization for synthesized import emission and cleanup.

Purpose: The transform adds imports like `qrl`, `_jsxSorted`, `_wrapProp`, `_fnSignal` during transformation. These need to be properly emitted at the module level and unused imports cleaned up. Currently imports are handled via `import_stack.pop()` but module-level synthesis needs explicit finalization.

Output: Clean module with synthesized imports at top, unused imports removed.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-imports-exports/06-RESEARCH.md
@optimizer/src/transform.rs
@optimizer/src/import_clean_up.rs
@optimizer/src/component/shared.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create synthesized_imports tracking</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add tracking for synthesized imports that need module-level emission:

1. Add field `synthesized_imports: BTreeSet<Import>` to TransformGenerator

2. Initialize as empty in constructor

3. When `needs_wrap_prop_import`, `needs_fn_signal_import`, `needs_val_import`, `needs_chk_import`, or `needs_inlined_qrl_import` flags are set, instead of adding to `import_stack.last_mut()`, add to `synthesized_imports` in `exit_program`.

4. The current logic in `exit_program` that checks these flags and adds to import_stack is fragile - refactor to:
   - Collect all synthesized imports in `synthesized_imports`
   - Emit them at module top in `exit_program`

Review current exit_program logic around lines 547-640 that handles:
- needs_wrap_prop_import (line 551-560)
- needs_fn_signal_import (line 562-569)
- needs_val_import (line 573-579)
- needs_chk_import (line 582-588)
- needs_inlined_qrl_import (line 591-597)
- Hoisted functions (line 604-635)
- import_stack.pop() and insertion (line 637-640)

Ensure the order remains: synthesized imports -> hoisted functions -> original body.
  </action>
  <verify>`cargo build -p qwik-optimizer` compiles</verify>
  <done>synthesized_imports BTreeSet tracks all synthesized imports</done>
</task>

<task type="auto">
  <name>Task 2: Deduplicate synthesized imports</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Prevent duplicate synthesized imports:

1. Before adding to `synthesized_imports`, check if the import already exists

2. The BTreeSet should handle deduplication automatically since Import implements Ord

3. Verify that multiple calls to `qrl()` don't produce duplicate `import { qrl } from "@qwik.dev/core"` statements

4. Add helper method `add_synthesized_import(&mut self, import: Import)` that:
   - Checks if import.names overlaps with existing imports from same source
   - Merges import specifiers if from same source (e.g., `{ qrl, _jsxSorted }` instead of two imports)

5. Update all sites that currently do `import_stack.last_mut().unwrap().insert(Import::new(...))` for synthesized imports to use the new helper

Key locations to update:
- QRL transformation (qrl import)
- JSX transformation (_jsxSorted import)
- Fragment handling (_Fragment from jsx-runtime)
- Props helpers (_restProps, _wrapProp, _fnSignal)
- Bind helpers (_val, _chk)
  </action>
  <verify>`cargo test` passes, no duplicate imports in output</verify>
  <done>Synthesized imports are deduplicated and merged by source</done>
</task>

<task type="auto">
  <name>Task 3: Test synthesized import deduplication</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add tests verifying synthesized import handling:

1. Test `test_synthesized_import_deduplication`:
```rust
#[test]
fn test_synthesized_import_deduplication() {
    let source = r#"
        import { component$, $ } from '@qwik.dev/core';

        export const App = component$(() => {
            return $(() => {
                return $(() => <div>nested</div>);
            });
        });
    "#;

    // Verify output has single `import { qrl, componentQrl, _jsxSorted } from "@qwik.dev/core"`
    // Not three separate qrl imports
}
```

2. Test `test_multiple_helper_imports`:
```rust
#[test]
fn test_multiple_helper_imports() {
    let source = r#"
        import { component$ } from '@qwik.dev/core';

        export const App = component$(({ msg, count }) => {
            return <input value={msg} bind:value={count} />;
        });
    "#;

    // Verify output has: import { _wrapProp, _val, ... } from "@qwik.dev/core"
    // All in one import statement, not separate
}
```
  </action>
  <verify>`cargo test test_synthesized_import` passes</verify>
  <done>Tests confirm synthesized imports are properly deduplicated and merged</done>
</task>

</tasks>

<verification>
1. `cargo build -p qwik-optimizer` compiles
2. `cargo test -p qwik-optimizer` passes (all 137+ tests)
3. Output code has single merged import for @qwik.dev/core
4. No duplicate import statements in any test output
</verification>

<success_criteria>
- synthesized_imports field tracks all synthesized imports
- Imports from same source are merged into single statement
- Module finalization emits synthesized imports at top
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-imports-exports/06-02-SUMMARY.md`
</output>
