---
phase: 02-qrl-core
plan: 05
type: execute
wave: 4
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - optimizer/src/transform.rs
  - optimizer/tests/qrl_parity.rs
autonomous: true

must_haves:
  truths:
    - "Arrow function QRLs extract correctly with proper hash"
    - "Function declaration QRLs extract correctly"
    - "Component$ transforms to componentQrl(qrl(...))"
    - "Nested QRLs link to parent segment"
    - "Ternary QRLs both branches transform"
    - "Multiple QRLs in same file get unique names"
    - "Captured variables appear in qrl() third argument"
  artifacts:
    - path: "optimizer/tests/qrl_parity.rs"
      provides: "Integration tests for QRL parity"
      contains: "fn test_qrl_"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "SWC snapshot output"
      via: "exact output match"
      pattern: "assert_eq.*expected"
---

<objective>
Wire all QRL components together and validate parity with SWC snapshot tests.

Purpose: This plan integrates all the pieces from Plans 01-04 and validates that the complete QRL transformation produces output matching SWC. This is the validation checkpoint for Phase 2.

Output: Working QRL transformation with parity tests proving correctness.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qrl-core/02-RESEARCH.md
@.planning/phases/02-qrl-core/02-02-SUMMARY.md
@.planning/phases/02-qrl-core/02-03-SUMMARY.md
@.planning/phases/02-qrl-core/02-04-SUMMARY.md

# SWC reference snapshots
@qwik-core/src/optimizer/core/src/snapshots/qwik_core__test__example_1.snap
@qwik-core/src/optimizer/core/src/snapshots/qwik_core__test__example_2.snap

# Existing OXC
@optimizer/src/transform.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire complete QRL transformation in TransformGenerator</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Complete the QRL transformation by wiring all components together in `exit_call_expression`:

```rust
fn exit_call_expression(&mut self, node: &mut CallExpression<'a>, ctx: &mut TraverseCtx<'a, ()>) {
    let segment = self.segment_stack.last();

    if let Some(segment) = segment {
        if segment.is_qrl() {
            let first_arg = node.arguments.first();
            if let Some(arg) = first_arg {
                // 1. Use IdentCollector to gather descendent identifiers
                let mut collector = IdentCollector::new();
                arg.visit_with(&mut collector);
                let descendent_idents = collector.get_words();

                // 2. Get all declarations from parent scopes
                let all_decl: Vec<IdPlusType> = self.decl_stack
                    .iter()
                    .flat_map(|v| v.iter())
                    .cloned()
                    .collect();

                // 3. Partition into valid and invalid declarations
                let (decl_collect, invalid_decl): (Vec<_>, Vec<_>) = all_decl
                    .into_iter()
                    .partition(|(_, t)| matches!(t, IdentType::Var(_)));

                // 4. Compute scoped identifiers
                let (scoped_idents, _is_const) = compute_scoped_idents(&descendent_idents, &decl_collect);

                // 5. Create SegmentData with all metadata
                let ctx_name = node.callee_name().unwrap_or_default().to_string();
                let parent_segment = self.segment_stack.iter()
                    .rev()
                    .skip(1)  // Skip current
                    .find(|s| s.is_qrl())
                    .map(|s| s.to_string());

                let segment_data = SegmentData::new(
                    &ctx_name,
                    self.current_display_name(),
                    self.current_hash(),
                    self.source_info.rel_path.clone(),
                    scoped_idents,
                    descendent_idents,
                    parent_segment,
                );

                // 6. Get collected imports
                let imports = self.import_stack
                    .pop()
                    .unwrap_or_default()
                    .iter()
                    .cloned()
                    .collect();

                // 7. Create QrlComponent with SegmentData
                let comp = QrlComponent::from_call_expression_argument(
                    arg,
                    imports,
                    &self.segment_stack,
                    &self.scope,
                    &self.options,
                    self.source_info,
                    segment_data,
                    ctx.ast.allocator,
                );

                // 8. Generate the QRL call expression
                let qrl = &comp.qrl;
                *node = qrl.into_call_expression(
                    ctx,
                    &mut self.symbol_by_name,
                    &mut self.import_by_symbol,
                );

                // 9. Store component and push import
                let import: Import = comp.qrl.qrl_type.clone().into();
                self.qrl_stack.push(comp.qrl.clone());
                self.components.push(comp);
                self.import_stack.last_mut().unwrap().insert(import);
            }
        }
    }
    self.segment_stack.pop();
}
```

Ensure all helper methods exist:
- `current_display_name()` - builds display name from segment_stack
- `current_hash()` - calculates hash for current context

Reference SWC transform.rs:650-786 for the complete pattern.
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Run existing tests `cargo test -p optimizer` - all pass.
  </verify>
  <done>
exit_call_expression uses all QRL components.
SegmentData is populated with scoped_idents and local_idents.
Parent segment linking works for nested QRLs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add captured variables to qrl() output</name>
  <files>optimizer/src/component/qrl.rs</files>
  <action>
Update `Qrl::into_call_expression` to include captured variables as third argument:

```rust
// In Qrl struct, add field:
pub scoped_idents: Vec<Id>,

// In into_arguments, add captures array:
fn into_arguments<'a>(&self, ast_builder: &AstBuilder<'a>) -> OxcVec<'a, Argument<'a>> {
    let allocator = ast_builder.allocator;

    // ARG 1: Lazy import arrow function
    let arrow_function = self.into_arrow_function(ast_builder);

    // ARG 2: Symbol name string literal
    let display_name_arg = ast_builder.string_literal(
        SPAN,
        ast_builder.atom(&self.display_name),
        None,
    );

    // ARG 3: Captured variables array (only if non-empty)
    let mut args = ast_builder.vec_with_capacity(3);
    args.push(Argument::ArrowFunctionExpression(OxcBox::new_in(arrow_function, allocator)));
    args.push(Argument::StringLiteral(OxcBox::new_in(display_name_arg, allocator)));

    if !self.scoped_idents.is_empty() {
        // Build array: [a, b, c]
        let elements: OxcVec<ArrayExpressionElement> = self.scoped_idents
            .iter()
            .map(|id| {
                ArrayExpressionElement::Identifier(
                    ast_builder.identifier_reference(SPAN, &id.0)
                )
            })
            .collect_in(allocator);

        let array = ast_builder.expression_array(SPAN, elements);
        args.push(Argument::from(array));
    }

    args
}
```

Update QrlComponent to pass scoped_idents when creating Qrl.
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Test that `qrl(() => ..., "name", [captures])` format is generated when captures exist.
  </verify>
  <done>
qrl() calls include third argument when there are captured variables.
Captured variable array matches scoped_idents ordering (sorted).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create QRL parity tests</name>
  <files>optimizer/tests/qrl_parity.rs</files>
  <action>
Create `optimizer/tests/qrl_parity.rs` with parity tests against SWC snapshots:

```rust
//! QRL transformation parity tests
//!
//! These tests verify that OXC output matches SWC output exactly.

use optimizer::{transform, Source, TransformOptions};

fn assert_parity(input: &str, expected_body: &str) {
    let source = Source::from_string("test.tsx", input);
    let options = TransformOptions::default();
    let result = transform(source, options).expect("transform failed");

    // Normalize whitespace for comparison
    let actual = result.optimized_app.body.trim();
    let expected = expected_body.trim();

    assert_eq!(actual, expected, "Output mismatch");
}

#[test]
fn test_qrl_arrow_function_basic() {
    // From example_1.snap - basic arrow function QRL
    let input = r#"
import { $, component$ } from '@qwik.dev/core';

export const App = component$(() => {
    return <div onClick$={() => console.log("hi")} />;
});
"#;

    // Expected output from SWC snapshot (simplified)
    let expected = r#"
import { componentQrl, qrl } from "@qwik.dev/core";

export const App = componentQrl(qrl(() => import("./test_App_component.js"), "App_component"));
"#;

    assert_parity(input, expected);
}

#[test]
fn test_qrl_with_captured_variables() {
    // QRL capturing a variable from outer scope
    let input = r#"
import { $, component$, useSignal } from '@qwik.dev/core';

export const Counter = component$(() => {
    const count = useSignal(0);
    return <button onClick$={() => count.value++}>+1</button>;
});
"#;

    // Expected: onClick handler should have [count] as third argument
    // and segment file should have useLexicalScope()
    let result = transform(
        Source::from_string("test.tsx", input),
        TransformOptions::default(),
    ).expect("transform failed");

    // Check main output has capture array
    assert!(result.optimized_app.body.contains("[count]"),
        "Should have capture array");

    // Check segment has useLexicalScope
    let segment = result.optimized_app.components
        .iter()
        .find(|c| c.id.display_name.contains("onClick"))
        .expect("Should have onClick segment");
    assert!(segment.code.contains("useLexicalScope"),
        "Segment should have useLexicalScope");
}

#[test]
fn test_qrl_nested_component_with_handler() {
    // From example_2.snap - nested QRLs
    let input = r#"
import { $, component$ } from '@qwik.dev/core';

export const Header = component$(() => {
    return <div onClick={$((ctx) => console.log(ctx))} />;
});
"#;

    let result = transform(
        Source::from_string("test.tsx", input),
        TransformOptions::default(),
    ).expect("transform failed");

    // Should have component segment and onClick segment
    assert_eq!(result.optimized_app.components.len(), 2,
        "Should have 2 segments");

    // onClick segment should have Header_component as parent
    let onclick_segment = result.optimized_app.components
        .iter()
        .find(|c| c.id.display_name.contains("onClick"))
        .expect("Should have onClick segment");

    assert!(onclick_segment.segment_data.parent_segment.is_some(),
        "Nested QRL should have parent segment");
}

#[test]
fn test_qrl_multiple_in_same_file() {
    // Multiple QRLs should get unique names
    let input = r#"
import { $ } from '@qwik.dev/core';

export const a = $(() => 1);
export const b = $(() => 2);
export const c = $(() => 3);
"#;

    let result = transform(
        Source::from_string("test.tsx", input),
        TransformOptions::default(),
    ).expect("transform failed");

    // Should have 3 unique segments
    assert_eq!(result.optimized_app.components.len(), 3);

    // All symbol names should be unique
    let names: Vec<_> = result.optimized_app.components
        .iter()
        .map(|c| &c.id.symbol_name)
        .collect();
    let unique_names: std::collections::HashSet<_> = names.iter().collect();
    assert_eq!(names.len(), unique_names.len(), "All names should be unique");
}

#[test]
fn test_qrl_in_ternary() {
    // QRL in ternary expression
    let input = r#"
import { $, component$, useSignal } from '@qwik.dev/core';

export const Toggle = component$(() => {
    const enabled = useSignal(true);
    const input = useSignal("");
    return (
        <input
            onInput$={enabled.value ? $((ev, el) => { input.value = el.value; }) : undefined}
        />
    );
});
"#;

    let result = transform(
        Source::from_string("test.tsx", input),
        TransformOptions::default(),
    ).expect("transform failed");

    // Should transform the QRL inside the ternary
    assert!(result.optimized_app.body.contains("qrl("),
        "Ternary QRL should be transformed");
}

#[test]
fn test_qrl_hash_stability() {
    // Same input should produce same hash
    let input = r#"
import { $ } from '@qwik.dev/core';
export const fn = $(() => console.log("test"));
"#;

    let result1 = transform(
        Source::from_string("test.tsx", input),
        TransformOptions::default(),
    ).expect("transform failed");

    let result2 = transform(
        Source::from_string("test.tsx", input),
        TransformOptions::default(),
    ).expect("transform failed");

    assert_eq!(
        result1.optimized_app.components[0].id.hash,
        result2.optimized_app.components[0].id.hash,
        "Hash should be stable across transforms"
    );
}
```

Note: Exact expected outputs should be taken from SWC snapshots. The tests above show the pattern - actual expected strings need to match SWC output exactly.
  </action>
  <verify>
Run `cargo test -p optimizer qrl_parity` - all tests pass.
  </verify>
  <done>
6 parity tests pass covering:
- Basic arrow function QRL
- Captured variables
- Nested QRLs with parent linking
- Multiple QRLs uniqueness
- Ternary QRL handling
- Hash stability
  </done>
</task>

</tasks>

<verification>
```bash
# Compile check
cargo check -p optimizer

# Run all optimizer tests
cargo test -p optimizer

# Run specific QRL parity tests
cargo test -p optimizer qrl_parity

# Verify parity test file exists
test -f optimizer/tests/qrl_parity.rs && echo "Parity tests exist" || echo "FAIL"
```
</verification>

<success_criteria>
1. Complete QRL transformation wired in exit_call_expression
2. qrl() calls include capture array when needed
3. 6+ parity tests pass
4. Hash generation matches SWC output
5. Nested QRLs correctly link to parent segment
6. All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-qrl-core/02-05-SUMMARY.md`
</output>
