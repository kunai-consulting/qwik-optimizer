---
phase: 02-qrl-core
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/transform.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "compute_scoped_idents matches identifiers by name regardless of ScopeId"
    - "Captured variables appear in scoped_idents when QRL references outer scope variables"
    - "qrl() calls include third argument [captures] when scoped_idents is non-empty"
    - "Segment files include useLexicalScope destructuring when captures exist"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Fixed compute_scoped_idents comparison logic"
      contains: "name comparison ignoring scope"
  key_links:
    - from: "transform.rs:compute_scoped_idents"
      to: "collector.rs:IdentCollector output"
      via: "name-only comparison"
      pattern: "ident\\.0.*==.*item\\.0\\.0"
---

<objective>
Fix capture detection bug where ScopeId mismatch prevents scoped_idents from being populated.

Purpose: Enable lexical scope capture to work correctly, satisfying QRL-07 and unblocking full QRL parity.
Output: Captured variables correctly detected and included in QRL transformation output.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-qrl-core/02-VERIFICATION.md
@optimizer/src/transform.rs
@optimizer/src/collector.rs
</context>

<gap_context>
**Root Cause (from VERIFICATION.md):**

The lexical scope capture system is structurally complete but semantically broken due to ScopeId mismatch:

1. IdentCollector (collector.rs:124) uses `ScopeId::new(0)` for all collected identifiers
2. decl_stack (transform.rs) uses `ctx.current_scope_id()` returning actual scope IDs
3. compute_scoped_idents compares `item.0 == *ident` which is tuple equality: `(name, scope_id) == (name, scope_id)`
4. Result: `(name, 0) != (name, actual_scope)` even when names match

**Recommended Fix (from verifier):**
Option 2 - Simplify Id comparison to use only names. For QRL capture purposes, name matching is sufficient since we're comparing within a single file's scope hierarchy.

**Evidence of bug:**
- test_qrl_with_captures.snap line 57: `qrl(() => import(...), "name")` - NO third argument
- test_qrl_with_captures.snap line 25: Segment file has NO useLexicalScope
- test_qrl_with_captures.snap line 43: `"captures": false`
</gap_context>

<tasks>

<task type="auto">
  <name>Task 1: Fix ScopeId comparison in compute_scoped_idents</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Modify compute_scoped_idents function (around line 1392) to compare identifiers by name only, ignoring ScopeId:

Current code (broken):
```rust
for ident in all_idents {
    if let Some(item) = all_decl.iter().find(|item| item.0 == *ident) {
```

Fixed code:
```rust
for ident in all_idents {
    // Compare by name only - ScopeId differences between IdentCollector (uses 0)
    // and decl_stack (uses actual scope) should not prevent capture detection
    if let Some(item) = all_decl.iter().find(|item| item.0.0 == ident.0) {
```

Key changes:
- Change `item.0 == *ident` to `item.0.0 == ident.0`
- This compares the name (String) at position 0 of the tuple, ignoring the ScopeId at position 1
- Add a comment explaining why name-only comparison is sufficient for QRL capture purposes

Also update the set.insert line to use the matched item's full Id (with correct scope) rather than the collector's Id:
```rust
set.insert(item.0.clone());  // Use the declaration's full Id
```
  </action>
  <verify>
First, confirm unit tests exist:
```bash
cargo test -p optimizer compute_scoped_idents -- --list
```
Should show test functions like `test_compute_scoped_idents_*`.

Then run the tests:
```bash
cargo test -p optimizer test_compute_scoped_idents
```
All unit tests for compute_scoped_idents should pass.
  </verify>
  <done>
compute_scoped_idents matches identifiers by name regardless of ScopeId differences.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify capture detection in integration tests</name>
  <files></files>
  <action>
This is a verification-only task - no files are modified. Snapshots will be updated via `cargo insta review` if needed (snapshot files are auto-managed by insta, not directly edited).

Run the QRL parity tests to verify capture detection now works:

```bash
cargo test -p optimizer test_qrl_with_captures -- --nocapture
```

Expected changes in snapshot:
1. Main file qrl() call should now have third argument: `qrl(() => import(...), "name", [count, name])`
2. Segment file should include useLexicalScope: `const [count, name] = useLexicalScope();`
3. JSON metadata should have `"captures": true`

If snapshot differs from expected, run `cargo insta review` to accept the corrected output.

Verify all 63 tests still pass:
```bash
cargo test -p optimizer
```
  </action>
  <verify>
`cargo test -p optimizer` - all 63 tests pass. Specifically, test_qrl_with_captures snapshot shows capture array in qrl() call and useLexicalScope in segment file.
  </verify>
  <done>
Captured variables correctly appear in QRL output - third argument in qrl() calls and useLexicalScope in segment files.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. Run `cargo test -p optimizer` - all 63 tests pass
2. Inspect test_qrl_with_captures snapshot - should show `[count, name]` as third argument
3. Inspect segment file in snapshot - should show `useLexicalScope()` destructuring
4. JSON metadata in snapshot - should show `"captures": true`
</verification>

<success_criteria>
- compute_scoped_idents correctly identifies captured variables by name matching
- test_qrl_with_captures output includes capture array in qrl() call
- test_qrl_with_captures segment file includes useLexicalScope injection
- All 63 existing tests pass
- QRL-07 requirement (QRL with captured variables) is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-qrl-core/02-06-SUMMARY.md`
</output>
