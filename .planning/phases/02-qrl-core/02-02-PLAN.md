---
phase: 02-qrl-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - optimizer/src/transform.rs
  - optimizer/src/component/mod.rs
autonomous: true

must_haves:
  truths:
    - "Scoped identifiers are computed by intersecting descendent idents with declaration stack"
    - "Scoped identifiers are sorted deterministically for stable output"
    - "Variables declared as const are tracked separately for is_const flag"
    - "Function and class declarations are filtered to invalid_decl"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "compute_scoped_idents function and decl_stack tracking"
      contains: "compute_scoped_idents"
    - path: "optimizer/src/transform.rs"
      provides: "Declaration stack tracking in TransformGenerator"
      contains: "decl_stack"
  key_links:
    - from: "optimizer/src/transform.rs:compute_scoped_idents"
      to: "optimizer/src/collector.rs:IdentCollector"
      via: "uses IdentCollector output as input"
      pattern: "compute_scoped_idents.*IdentCollector"
---

<objective>
Implement lexical scope capture by porting compute_scoped_idents and decl_stack tracking from SWC.

Purpose: This enables tracking which variables from enclosing scope are used inside a QRL, which is required for generating the `[captures]` array in `qrl()` calls and injecting `useLexicalScope()` in segment files.

Output: `compute_scoped_idents` function and `decl_stack` management integrated into TransformGenerator.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qrl-core/02-RESEARCH.md
@.planning/phases/02-qrl-core/02-01-SUMMARY.md

# SWC reference
@qwik-core/src/optimizer/core/src/transform.rs (lines 3582-3596 for compute_scoped_idents)
@qwik-core/src/optimizer/core/src/transform.rs (lines 80-87 for IdentType)

# Existing OXC transform
@optimizer/src/transform.rs
@optimizer/src/collector.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IdentType and decl_stack to TransformGenerator</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add declaration tracking infrastructure to TransformGenerator:

1. Add `IdentType` enum near top of file (after imports):
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum IdentType {
    Var(bool),  // bool = is_const
    Fn,
    Class,
}

pub type IdPlusType = (Id, IdentType);
```
Where `Id` is whatever identifier type is used in collector.rs (likely `(String, ScopeId)` or similar).

2. Add `decl_stack: Vec<Vec<IdPlusType>>` field to TransformGenerator struct.

3. Initialize `decl_stack: vec![Vec::new()]` in `TransformGenerator::new()`.

4. Add tracking in visitor methods:
   - `enter_variable_declarator`: Push to current decl_stack level
     - Determine IdentType::Var(is_const) from `node.kind == VariableDeclarationKind::Const`
   - `enter_function`: Push new Vec to decl_stack, track function name as IdentType::Fn
   - `exit_function`: Pop from decl_stack
   - `enter_class`: Push new Vec to decl_stack, track class name as IdentType::Class
   - `exit_class`: Pop from decl_stack
   - `enter_block_statement`: Push new Vec to decl_stack
   - `exit_block_statement`: Pop from decl_stack

Reference SWC transform.rs for exact tracking logic. The key is that each scope level has its own Vec of declarations.
  </action>
  <verify>
Run `cargo check -p optimizer` - no compilation errors.
Run existing tests `cargo test -p optimizer` - all pass (no regressions).
  </verify>
  <done>
IdentType enum and decl_stack field exist.
Visitor methods track declarations correctly.
Existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement compute_scoped_idents function</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Port `compute_scoped_idents` from SWC transform.rs:3582-3596:

```rust
fn compute_scoped_idents(all_idents: &[Id], all_decl: &[IdPlusType]) -> (Vec<Id>, bool) {
    let mut set: HashSet<Id> = HashSet::new();
    let mut is_const = true;

    for ident in all_idents {
        if let Some(item) = all_decl.iter().find(|item| item.0 == *ident) {
            set.insert(ident.clone());
            if !matches!(item.1, IdentType::Var(true)) {
                is_const = false;
            }
        }
    }

    let mut output: Vec<Id> = set.into_iter().collect();
    output.sort();  // Deterministic ordering for stable output
    (output, is_const)
}
```

Key semantics:
1. `all_idents` comes from IdentCollector on the QRL function body
2. `all_decl` is flattened from decl_stack (variables declared in parent scopes)
3. Return tuple: (sorted captured identifiers, whether all are const)
4. **CRITICAL**: Output MUST be sorted - SWC does `output.sort()` for deterministic hashes

Add as a free function or method on TransformGenerator.
  </action>
  <verify>
Add inline test:
```rust
#[test]
fn test_compute_scoped_idents() {
    let idents = vec![("a".into(), 0), ("b".into(), 0), ("c".into(), 0)];
    let decls = vec![
        (("a".into(), 0), IdentType::Var(true)),
        (("b".into(), 0), IdentType::Var(false)),
    ];
    let (scoped, is_const) = compute_scoped_idents(&idents, &decls);
    assert_eq!(scoped, vec![("a".into(), 0), ("b".into(), 0)]); // sorted
    assert_eq!(is_const, false); // b is not const
}
```
Run `cargo test -p optimizer compute_scoped` - test passes.
  </verify>
  <done>
compute_scoped_idents function exists and returns sorted identifiers.
Test verifies correct behavior for const tracking and sorting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate scope capture into QRL transformation</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Update `exit_call_expression` to use scope capture:

1. Before creating QrlComponent, collect identifiers:
```rust
// In exit_call_expression, when segment.is_qrl()
let first_arg = node.arguments.first();
if let Some(arg) = first_arg {
    // Collect descendent idents using IdentCollector
    let mut collector = IdentCollector::new();
    arg.visit_with(&mut collector);
    let descendent_idents = collector.get_words();

    // Get all declarations from parent scopes
    let all_decl: Vec<IdPlusType> = self.decl_stack
        .iter()
        .flat_map(|v| v.iter())
        .cloned()
        .collect();

    // Partition into valid (Var) and invalid (Fn, Class)
    let (decl_collect, invalid_decl): (Vec<_>, Vec<_>) = all_decl
        .into_iter()
        .partition(|(_, t)| matches!(t, IdentType::Var(_)));

    // Compute scoped identifiers
    let (scoped_idents, is_const) = compute_scoped_idents(&descendent_idents, &decl_collect);

    // Store scoped_idents for use in QrlComponent creation
}
```

2. Pass `scoped_idents` to `QrlComponent::from_call_expression_argument` - this may require updating the function signature to accept captured variables.

3. Add error handling for invalid_decl references (functions/classes captured in QRL):
```rust
for id in &invalid_decl {
    if descendent_idents.contains(&id.0) {
        self.errors.push(ProcessingFailure::from(/* function reference error */));
    }
}
```

Reference SWC transform.rs:680-754 for the exact integration pattern.
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Run `cargo test -p optimizer` - all tests pass.
  </verify>
  <done>
Scope capture is integrated into QRL transformation.
scoped_idents are computed and available for QrlComponent creation.
Invalid function/class references are detected and reported.
  </done>
</task>

</tasks>

<verification>
```bash
# Compile check
cargo check -p optimizer

# Run all optimizer tests
cargo test -p optimizer

# Check for compute_scoped_idents
grep -q "compute_scoped_idents" optimizer/src/transform.rs && echo "Function exists" || echo "FAIL"

# Check for decl_stack
grep -q "decl_stack" optimizer/src/transform.rs && echo "decl_stack exists" || echo "FAIL"
```
</verification>

<success_criteria>
1. IdentType enum exists with Var(bool), Fn, Class variants
2. decl_stack tracks declarations across scope boundaries
3. compute_scoped_idents returns sorted identifiers with is_const flag
4. QRL transformation uses scope capture to compute captured variables
5. All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-qrl-core/02-02-SUMMARY.md`
</output>
