---
phase: 02-qrl-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - optimizer/src/component/segment_data.rs
  - optimizer/src/component/mod.rs
  - optimizer/src/component/qrl_component.rs
autonomous: true

must_haves:
  truths:
    - "SegmentData contains all metadata required for segment files"
    - "ctx_kind distinguishes Function, EventHandler, and JSXProp"
    - "scoped_idents are stored for useLexicalScope injection"
    - "parent_segment links nested QRLs to their containing segment"
  artifacts:
    - path: "optimizer/src/component/segment_data.rs"
      provides: "SegmentData and SegmentKind types"
      contains: "pub struct SegmentData"
    - path: "optimizer/src/component/segment_data.rs"
      provides: "SegmentKind enum"
      contains: "pub enum SegmentKind"
  key_links:
    - from: "optimizer/src/component/qrl_component.rs"
      to: "optimizer/src/component/segment_data.rs"
      via: "QrlComponent stores SegmentData"
      pattern: "segment_data.*SegmentData"
---

<objective>
Create SegmentData structure to hold all segment metadata required for code generation.

Purpose: SegmentData captures the complete context of a QRL extraction - captured variables, parent segment, context kind, and all other metadata needed to generate segment files with proper imports and useLexicalScope injection.

Output: SegmentData struct matching SWC's Segment data structure, integrated into QrlComponent.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qrl-core/02-RESEARCH.md
@.planning/phases/02-qrl-core/02-01-SUMMARY.md

# SWC reference
@qwik-core/src/optimizer/core/src/transform.rs (lines 45-78 for SegmentKind and SegmentData)

# Existing OXC component
@optimizer/src/component/mod.rs
@optimizer/src/component/qrl_component.rs
@optimizer/src/component/id.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SegmentKind enum</name>
  <files>optimizer/src/component/segment_data.rs, optimizer/src/component/mod.rs</files>
  <action>
Create `optimizer/src/component/segment_data.rs` with SegmentKind enum:

```rust
use serde::{Deserialize, Serialize};

/// Indicates the context type of a QRL segment
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub enum SegmentKind {
    /// Regular function QRL (e.g., $(() => ...))
    Function,
    /// Event handler QRL (e.g., onClick$(() => ...))
    EventHandler,
    /// JSX prop QRL (e.g., prop$={...})
    JSXProp,
}

impl Default for SegmentKind {
    fn default() -> Self {
        SegmentKind::Function
    }
}
```

Add `SegmentKind::from_ctx_name(&str) -> SegmentKind` method:
- If starts with "on" -> EventHandler
- If in JSX attribute context -> JSXProp
- Otherwise -> Function

This matches SWC's ctx_kind determination logic.

Add to `optimizer/src/component/mod.rs`:
```rust
pub mod segment_data;
pub use segment_data::*;
```
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Test SegmentKind::from_ctx_name returns correct variant.
  </verify>
  <done>
SegmentKind enum exists with Function, EventHandler, JSXProp variants.
from_ctx_name method correctly categorizes context names.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SegmentData struct</name>
  <files>optimizer/src/component/segment_data.rs</files>
  <action>
Add SegmentData struct to `segment_data.rs`:

```rust
use std::path::PathBuf;

/// Complete metadata for a QRL segment
#[derive(Debug, Clone, Serialize)]
pub struct SegmentData {
    /// File extension (e.g., "js", "ts")
    pub extension: String,

    /// All identifiers used within the segment (for import generation)
    pub local_idents: Vec<Id>,

    /// Identifiers captured from enclosing scope (for useLexicalScope)
    pub scoped_idents: Vec<Id>,

    /// Parent segment name for nested QRLs (None if top-level)
    pub parent_segment: Option<String>,

    /// Context kind (Function, EventHandler, JSXProp)
    pub ctx_kind: SegmentKind,

    /// Context name (e.g., "onClick$", "component$")
    pub ctx_name: String,

    /// Origin file path (relative)
    pub origin: PathBuf,

    /// Directory path
    pub path: PathBuf,

    /// Human-readable display name
    pub display_name: String,

    /// Hash string for segment identification
    pub hash: String,

    /// Whether the segment needs transformation (useLexicalScope injection)
    pub need_transform: bool,
}

impl SegmentData {
    pub fn new(
        ctx_name: &str,
        display_name: String,
        hash: String,
        origin: PathBuf,
        scoped_idents: Vec<Id>,
        local_idents: Vec<Id>,
        parent_segment: Option<String>,
    ) -> Self {
        let ctx_kind = SegmentKind::from_ctx_name(ctx_name);
        let need_transform = !scoped_idents.is_empty();

        Self {
            extension: "js".to_string(),
            local_idents,
            scoped_idents,
            parent_segment,
            ctx_kind,
            ctx_name: ctx_name.to_string(),
            origin: origin.clone(),
            path: origin.parent().unwrap_or(&origin).to_path_buf(),
            display_name,
            hash,
            need_transform,
        }
    }

    /// Returns true if this segment has captured variables
    pub fn has_captures(&self) -> bool {
        !self.scoped_idents.is_empty()
    }
}
```

Ensure `Id` type is imported from collector module or defined locally.
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Verify SegmentData fields match SWC's SegmentData structure.
  </verify>
  <done>
SegmentData struct contains all required fields.
Constructor correctly initializes ctx_kind and need_transform.
has_captures() method works correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate SegmentData into QrlComponent</name>
  <files>optimizer/src/component/qrl_component.rs</files>
  <action>
Update QrlComponent to include SegmentData:

1. Add `segment_data: SegmentData` field to QrlComponent struct.

2. Update `from_call_expression_argument` to accept and store SegmentData:
```rust
pub fn from_call_expression_argument(
    arg0: &Argument<'_>,
    imports: Vec<Import>,
    segment_stack: &Vec<Segment>,
    scope: &Option<String>,
    options: &TransformOptions,
    source_info: &SourceInfo,
    segment_data: SegmentData,  // NEW
    allocator: &'_ Allocator,
) -> Self {
    // ... existing code ...
    Self {
        // ... existing fields ...
        segment_data,
    }
}
```

3. Add accessor methods:
```rust
impl QrlComponent {
    /// Returns the captured variable identifiers
    pub fn scoped_idents(&self) -> &[Id] {
        &self.segment_data.scoped_idents
    }

    /// Returns the local identifiers used in the segment
    pub fn local_idents(&self) -> &[Id] {
        &self.segment_data.local_idents
    }

    /// Returns the parent segment name if this is a nested QRL
    pub fn parent_segment(&self) -> Option<&str> {
        self.segment_data.parent_segment.as_deref()
    }
}
```

4. Update any callers of `from_call_expression_argument` in transform.rs to pass SegmentData (can be a stub for now that will be completed in Plan 04).
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Run `cargo test -p optimizer` - all tests pass.
  </verify>
  <done>
QrlComponent contains SegmentData.
Accessor methods expose segment metadata.
All callers updated (possibly with stub SegmentData).
  </done>
</task>

</tasks>

<verification>
```bash
# Compile check
cargo check -p optimizer

# Run all tests
cargo test -p optimizer

# Verify SegmentKind exists
grep -q "pub enum SegmentKind" optimizer/src/component/segment_data.rs && echo "SegmentKind exists" || echo "FAIL"

# Verify SegmentData exists
grep -q "pub struct SegmentData" optimizer/src/component/segment_data.rs && echo "SegmentData exists" || echo "FAIL"

# Verify integration
grep -q "segment_data" optimizer/src/component/qrl_component.rs && echo "Integration exists" || echo "FAIL"
```
</verification>

<success_criteria>
1. SegmentKind enum with Function, EventHandler, JSXProp variants
2. SegmentData struct with all SWC-equivalent fields
3. QrlComponent contains SegmentData field
4. Accessor methods for scoped_idents, local_idents, parent_segment
5. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-qrl-core/02-03-SUMMARY.md`
</output>
