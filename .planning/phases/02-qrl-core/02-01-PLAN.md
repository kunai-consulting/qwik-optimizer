---
phase: 02-qrl-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/collector.rs
  - optimizer/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "IdentCollector traverses AST and collects variable references"
    - "Builtin identifiers (undefined, NaN, Infinity, null) are excluded"
    - "Property keys and member expression properties are skipped"
    - "JSX element names starting with uppercase are tracked"
  artifacts:
    - path: "optimizer/src/collector.rs"
      provides: "IdentCollector visitor for variable usage collection"
      contains: "impl Visit for IdentCollector"
    - path: "optimizer/src/lib.rs"
      provides: "Module exports collector"
      contains: "mod collector"
  key_links:
    - from: "optimizer/src/collector.rs"
      to: "oxc_ast_visit::Visit"
      via: "trait implementation"
      pattern: "impl Visit.*IdentCollector"
---

<objective>
Port IdentCollector from SWC to OXC for variable usage collection in QRL expressions.

Purpose: IdentCollector is the foundation for lexical scope capture. It traverses QRL function bodies to identify which variables are referenced, which is essential for generating the `[captures]` array in `qrl()` calls.

Output: A new `collector.rs` module with `IdentCollector` that matches SWC behavior for identifier collection.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qrl-core/02-RESEARCH.md

# SWC reference implementation
@qwik-core/src/optimizer/core/src/collector.rs (lines 300-394 for IdentCollector)

# Existing OXC transform
@optimizer/src/transform.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create collector.rs with IdentCollector</name>
  <files>optimizer/src/collector.rs, optimizer/src/lib.rs</files>
  <action>
Create `optimizer/src/collector.rs` porting `IdentCollector` from SWC `collector.rs:300-394`.

Key implementation details:
1. Create `ExprOrSkip` enum to track expression context (same as SWC)
2. Implement `IdentCollector` struct with:
   - `local_idents: HashSet<Id>` where Id is `(String, ScopeId)` or similar
   - `use_h: bool` and `use_fragment: bool` flags for JSX
   - `expr_ctxt: Vec<ExprOrSkip>` context stack
3. Implement `oxc_ast_visit::Visit` trait:
   - `visit_expr`: Push `Expr` context, visit children, pop
   - `visit_stmt`: Push `Skip` context, visit children, pop
   - `visit_ident`: Collect if in Expr context and not builtin (undefined, NaN, Infinity, null)
   - `visit_key_value_prop`: Push Skip context to skip property keys
   - `visit_member_expr`: Push Skip context to skip property access
   - `visit_jsx_element`: Set use_h flag
   - `visit_jsx_fragment`: Set use_h and use_fragment flags
   - `visit_jsx_element_name`: Only visit children if identifier starts with uppercase
4. Add `get_words()` method that returns sorted Vec<Id>
5. Add module to `lib.rs`: `pub mod collector;`

Use OXC's `oxc_ast_visit::Visit` trait instead of SWC's visitor pattern.
For Id type, use a tuple similar to SWC's `(Atom, SyntaxContext)` but adapted for OXC's `(String, ScopeId)` or use existing patterns from transform.rs.

Do NOT use SWC-specific types like `swc_atoms::Atom` or `SyntaxContext`. Use OXC equivalents.
  </action>
  <verify>
Run `cargo check -p optimizer` - no compilation errors.
Verify `IdentCollector` is exported from the collector module.
  </verify>
  <done>
IdentCollector compiles and exports `new()`, `get_words()` methods.
Visit trait implementation handles all required AST nodes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for IdentCollector</name>
  <files>optimizer/src/collector.rs</files>
  <action>
Add test module to `collector.rs` with tests verifying:

1. **Basic identifier collection**:
   - Input: Parse `const x = a + b;` and visit
   - Expected: `local_idents` contains `a` and `b`

2. **Builtin exclusion**:
   - Input: Parse `const x = undefined + NaN + Infinity + null;`
   - Expected: `local_idents` is empty

3. **Property key skipping**:
   - Input: Parse `const x = { foo: bar };`
   - Expected: `local_idents` contains only `bar`, not `foo`

4. **Member expression property skipping**:
   - Input: Parse `const x = obj.prop;`
   - Expected: `local_idents` contains `obj`, not `prop`

5. **JSX element tracking**:
   - Input: Parse `const x = <div />;`
   - Expected: `use_h` is true

6. **JSX fragment tracking**:
   - Input: Parse `const x = <></>;`
   - Expected: `use_h` and `use_fragment` are true

7. **Sorted output**:
   - Input: Parse `const x = c + a + b;`
   - Expected: `get_words()` returns `["a", "b", "c"]` (sorted)

Use OXC's parser to create AST for testing. Pattern from existing tests in transform.rs.
  </action>
  <verify>
Run `cargo test -p optimizer collector` - all tests pass.
  </verify>
  <done>
7 unit tests pass covering identifier collection, builtin exclusion, property skipping, JSX tracking, and sorted output.
  </done>
</task>

</tasks>

<verification>
```bash
# Compile check
cargo check -p optimizer

# Run collector tests
cargo test -p optimizer collector

# Verify module is exported
grep -q "pub mod collector" optimizer/src/lib.rs && echo "Module exported" || echo "FAIL: Module not exported"
```
</verification>

<success_criteria>
1. `optimizer/src/collector.rs` exists with IdentCollector implementation
2. IdentCollector implements Visit trait for OXC AST
3. All 7 unit tests pass
4. `cargo check -p optimizer` succeeds
5. Module is exported from lib.rs
</success_criteria>

<output>
After completion, create `.planning/phases/02-qrl-core/02-01-SUMMARY.md`
</output>
