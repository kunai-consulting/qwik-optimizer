---
phase: 02-qrl-core
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - optimizer/src/code_move.rs
  - optimizer/src/lib.rs
  - optimizer/src/component/component.rs
autonomous: true

must_haves:
  truths:
    - "useLexicalScope injection creates const [a, b] = useLexicalScope() at function start"
    - "Arrow functions with expression body are converted to block body"
    - "Function declarations have useLexicalScope prepended to body"
    - "Segment modules include imports for all local_idents"
  artifacts:
    - path: "optimizer/src/code_move.rs"
      provides: "transform_function_expr and useLexicalScope injection"
      contains: "transform_function_expr"
    - path: "optimizer/src/code_move.rs"
      provides: "create_use_lexical_scope statement generation"
      contains: "create_use_lexical_scope"
  key_links:
    - from: "optimizer/src/component/component.rs"
      to: "optimizer/src/code_move.rs"
      via: "calls transform_function_expr during code generation"
      pattern: "transform_function_expr"
---

<objective>
Port code_move.rs from SWC to OXC for useLexicalScope injection in segment files.

Purpose: When a QRL captures variables from enclosing scope, the segment file needs to import those via `useLexicalScope()`. This plan implements the AST transformation that injects `const [a, b, c] = useLexicalScope();` at the start of extracted functions.

Output: code_move.rs module with transform_function_expr and segment module generation.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qrl-core/02-RESEARCH.md
@.planning/phases/02-qrl-core/02-02-SUMMARY.md
@.planning/phases/02-qrl-core/02-03-SUMMARY.md

# SWC reference
@qwik-core/src/optimizer/core/src/code_move.rs

# Existing OXC component
@optimizer/src/transform.rs
@optimizer/src/component/component.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create code_move.rs with useLexicalScope injection</name>
  <files>optimizer/src/code_move.rs, optimizer/src/lib.rs</files>
  <action>
Create `optimizer/src/code_move.rs` porting from SWC code_move.rs:175-290:

```rust
use oxc_allocator::{Allocator, Box as OxcBox, Vec as OxcVec};
use oxc_ast::ast::*;
use oxc_ast::AstBuilder;
use oxc_span::SPAN;

/// Transforms a function expression to include useLexicalScope destructuring.
///
/// For arrow functions with expression body:
///   () => expr  ->  () => { const [a, b] = useLexicalScope(); return expr; }
///
/// For arrow functions with block body:
///   () => { ... }  ->  () => { const [a, b] = useLexicalScope(); ... }
///
/// For function expressions:
///   function() { ... }  ->  function() { const [a, b] = useLexicalScope(); ... }
pub fn transform_function_expr<'a>(
    expr: Expression<'a>,
    use_lexical_scope_name: &str,
    scoped_idents: &[Id],
    ast: &AstBuilder<'a>,
) -> Expression<'a> {
    if scoped_idents.is_empty() {
        return expr;
    }

    match expr {
        Expression::ArrowFunctionExpression(arrow) => {
            Expression::ArrowFunctionExpression(OxcBox::new_in(
                transform_arrow_fn(*arrow, use_lexical_scope_name, scoped_idents, ast),
                ast.allocator,
            ))
        }
        Expression::FunctionExpression(func) => {
            Expression::FunctionExpression(OxcBox::new_in(
                transform_fn(*func, use_lexical_scope_name, scoped_idents, ast),
                ast.allocator,
            ))
        }
        _ => expr,
    }
}

fn transform_arrow_fn<'a>(
    arrow: ArrowFunctionExpression<'a>,
    use_lexical_scope_name: &str,
    scoped_idents: &[Id],
    ast: &AstBuilder<'a>,
) -> ArrowFunctionExpression<'a> {
    let use_lexical_stmt = create_use_lexical_scope(use_lexical_scope_name, scoped_idents, ast);

    let new_body = match arrow.body {
        FunctionBody::FunctionBody(mut block) => {
            // Block body: prepend useLexicalScope
            let mut stmts = ast.vec_with_capacity(1 + block.statements.len());
            stmts.push(use_lexical_stmt);
            stmts.extend(block.statements.drain(..));
            ast.function_body(SPAN, ast.vec(), stmts)
        }
        FunctionBody::Expression(expr) => {
            // Expression body: convert to block with return
            let return_stmt = ast.statement_return(SPAN, Some(expr));
            let stmts = ast.vec_from_array([use_lexical_stmt, return_stmt]);
            ast.function_body(SPAN, ast.vec(), stmts)
        }
    };

    ArrowFunctionExpression {
        body: new_body,
        ..arrow
    }
}

fn transform_fn<'a>(
    func: Function<'a>,
    use_lexical_scope_name: &str,
    scoped_idents: &[Id],
    ast: &AstBuilder<'a>,
) -> Function<'a> {
    let use_lexical_stmt = create_use_lexical_scope(use_lexical_scope_name, scoped_idents, ast);

    let new_body = match func.body {
        Some(mut body) => {
            let mut stmts = ast.vec_with_capacity(1 + body.statements.len());
            stmts.push(use_lexical_stmt);
            stmts.extend(body.statements.drain(..));
            Some(ast.function_body(SPAN, ast.vec(), stmts))
        }
        None => {
            let stmts = ast.vec1(use_lexical_stmt);
            Some(ast.function_body(SPAN, ast.vec(), stmts))
        }
    };

    Function {
        body: new_body,
        ..func
    }
}

/// Creates: const [a, b, c] = useLexicalScope();
fn create_use_lexical_scope<'a>(
    use_lexical_scope_name: &str,
    scoped_idents: &[Id],
    ast: &AstBuilder<'a>,
) -> Statement<'a> {
    // Build array pattern: [a, b, c]
    let elements: OxcVec<Option<BindingPatternKind>> = scoped_idents
        .iter()
        .map(|id| {
            Some(ast.binding_pattern_kind_binding_identifier(
                SPAN,
                ast.atom(&id.0), // Assuming Id is (String, _)
            ))
        })
        .collect_in(ast.allocator);

    let array_pattern = ast.binding_pattern(
        ast.binding_pattern_kind_array_pattern(SPAN, elements, None::<OxcBox<BindingRestElement>>),
        None::<OxcBox<TSTypeAnnotation>>,
    );

    // Build call: useLexicalScope()
    let callee = ast.expression_identifier(SPAN, use_lexical_scope_name);
    let call = ast.expression_call(
        SPAN,
        callee,
        None::<OxcBox<TSTypeParameterInstantiation>>,
        ast.vec(),
        false,
    );

    // Build: const [a, b, c] = useLexicalScope();
    let declarator = ast.variable_declarator(SPAN, VariableDeclarationKind::Const, array_pattern, Some(call), false);
    let declaration = ast.variable_declaration(
        SPAN,
        VariableDeclarationKind::Const,
        ast.vec1(declarator),
        false,
    );

    Statement::VariableDeclaration(OxcBox::new_in(declaration, ast.allocator))
}
```

Add to `optimizer/src/lib.rs`:
```rust
pub mod code_move;
```

Note: Adapt the exact OXC AST building APIs based on what's available in the codebase. The pattern should match existing code in transform.rs.
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Verify function signatures match expected inputs/outputs.
  </verify>
  <done>
code_move.rs exists with transform_function_expr.
Arrow function expression body -> block body conversion works.
useLexicalScope statement is correctly generated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for code_move transformations</name>
  <files>optimizer/src/code_move.rs</files>
  <action>
Add test module to code_move.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use oxc_allocator::Allocator;
    use oxc_codegen::Codegen;
    use oxc_parser::Parser;
    use oxc_span::SourceType;

    fn transform_and_render(code: &str, scoped_idents: &[(&str, usize)]) -> String {
        let allocator = Allocator::default();
        let source_type = SourceType::default().with_module(true);
        let parsed = Parser::new(&allocator, code, source_type).parse();
        let ast = AstBuilder::new(&allocator);

        // Extract expression from parsed program
        // ... (implement based on actual AST structure)

        // Transform and render back to string
        // ...
    }

    #[test]
    fn test_arrow_expression_body() {
        // () => x + y  ->  () => { const [x, y] = useLexicalScope(); return x + y; }
        let input = "() => x + y";
        let scoped = vec![("x", 0), ("y", 0)];
        let output = transform_and_render(input, &scoped);
        assert!(output.contains("useLexicalScope"));
        assert!(output.contains("return x + y"));
    }

    #[test]
    fn test_arrow_block_body() {
        // () => { return x; }  ->  () => { const [x] = useLexicalScope(); return x; }
        let input = "() => { return x; }";
        let scoped = vec![("x", 0)];
        let output = transform_and_render(input, &scoped);
        assert!(output.contains("useLexicalScope"));
        // useLexicalScope should be FIRST statement
    }

    #[test]
    fn test_function_expression() {
        // function() { return x; }  ->  function() { const [x] = useLexicalScope(); return x; }
        let input = "function() { return x; }";
        let scoped = vec![("x", 0)];
        let output = transform_and_render(input, &scoped);
        assert!(output.contains("useLexicalScope"));
    }

    #[test]
    fn test_empty_scoped_idents_no_change() {
        let input = "() => x + y";
        let scoped: Vec<(&str, usize)> = vec![];
        let output = transform_and_render(input, &scoped);
        assert!(!output.contains("useLexicalScope"));
    }

    #[test]
    fn test_sorted_idents_in_destructuring() {
        // Idents should appear sorted in destructuring pattern
        let input = "() => c + a + b";
        let scoped = vec![("a", 0), ("b", 0), ("c", 0)]; // Already sorted
        let output = transform_and_render(input, &scoped);
        // Should be: const [a, b, c] = useLexicalScope()
        assert!(output.contains("[a, b, c]") || output.contains("[a,b,c]"));
    }
}
```

Note: Actual test implementation depends on how to extract/parse individual expressions. May need to wrap in a statement for parsing.
  </action>
  <verify>
Run `cargo test -p optimizer code_move` - all tests pass.
  </verify>
  <done>
5 unit tests pass covering:
- Arrow expression body conversion
- Arrow block body prepending
- Function expression transformation
- No-op for empty scoped_idents
- Sorted destructuring pattern
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate code_move into QrlComponent code generation</name>
  <files>optimizer/src/component/component.rs</files>
  <action>
Update QrlComponent in `optimizer/src/component/component.rs` to use code_move for segment code generation.

The `QrlComponent::gen` method generates segment file code. Update it to call `transform_function_expr` when the segment has captured variables (scoped_idents).

1. Add import at top of file:
```rust
use crate::code_move::transform_function_expr;
```

2. Update `QrlComponent::gen` or `QrlComponent::new` to accept scoped_idents and call transform_function_expr:
```rust
// Before generating code, transform the expression if it has captures
let transformed_expr = if !scoped_idents.is_empty() {
    transform_function_expr(
        exported_expression,
        "useLexicalScope",
        &scoped_idents,
        &ast_builder,
    )
} else {
    exported_expression
};
```

3. Update `from_expression` and `from_call_expression_argument` to pass scoped_idents through.

Note: The exact implementation depends on how SegmentData from Plan 02-02/02-03 provides scoped_idents. The key requirement is that when generating segment file code, we apply transform_function_expr if there are captures.
  </action>
  <verify>
Run `cargo check -p optimizer` - compiles.
Run `cargo test -p optimizer` - all tests pass.

Verify integration is wired correctly:
```bash
# Confirm transform_function_expr is called from component.rs
grep -q "transform_function_expr" optimizer/src/component/component.rs && echo "Integration confirmed: transform_function_expr in component.rs" || echo "FAIL: transform_function_expr not found in component.rs"
```

Alternative verification via test output (if unit tests produce segment code with captures):
```bash
# Run code_move tests with output to confirm useLexicalScope appears
cargo test -p optimizer code_move -- --nocapture 2>&1 | grep -q "useLexicalScope" && echo "useLexicalScope appears in test output" || echo "Check test assertions directly"
```
  </verify>
  <done>
QrlComponent can generate segment code with useLexicalScope injection.
transform_function_expr is imported and called from component.rs when scoped_idents is non-empty.
Integration verified: `grep "transform_function_expr" optimizer/src/component/component.rs` returns a match.
  </done>
</task>

</tasks>

<verification>
```bash
# Compile check
cargo check -p optimizer

# Run all tests including code_move tests
cargo test -p optimizer

# Verify code_move exists
grep -q "transform_function_expr" optimizer/src/code_move.rs && echo "Function exists" || echo "FAIL"

# Verify useLexicalScope generation
grep -q "create_use_lexical_scope" optimizer/src/code_move.rs && echo "Statement gen exists" || echo "FAIL"

# Verify integration: transform_function_expr is called from component.rs
grep -q "transform_function_expr" optimizer/src/component/component.rs && echo "Integration confirmed" || echo "FAIL: Integration missing"
```
</verification>

<success_criteria>
1. code_move.rs exists with transform_function_expr function
2. Arrow expression body -> block body conversion implemented
3. useLexicalScope statement correctly generated with array destructuring
4. 5 unit tests pass
5. QrlComponent uses transform for segment code generation (verified by grep showing transform_function_expr in component.rs)
</success_criteria>

<output>
After completion, create `.planning/phases/02-qrl-core/02-04-SUMMARY.md`
</output>
