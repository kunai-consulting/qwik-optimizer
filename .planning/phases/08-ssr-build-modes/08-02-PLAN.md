---
phase: 08-ssr-build-modes
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - optimizer/src/const_replace.rs
  - optimizer/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "isServer identifiers replaced with boolean literal based on is_server option"
    - "isBrowser identifiers replaced with !is_server (inverse of isServer)"
    - "isDev identifiers replaced with boolean literal based on target == Dev"
    - "Aliased imports handled correctly (import { isServer as s })"
    - "Both @qwik.dev/core and @qwik.dev/core/build sources handled"
  artifacts:
    - path: "optimizer/src/const_replace.rs"
      provides: "ConstReplacerVisitor for SSR/build mode const replacement"
      exports: ["ConstReplacerVisitor"]
    - path: "optimizer/src/lib.rs"
      provides: "Module export for const_replace"
      contains: "mod const_replace"
  key_links:
    - from: "optimizer/src/const_replace.rs"
      to: "optimizer/src/component/shared.rs"
      via: "use of IS_SERVER, IS_BROWSER, IS_DEV, QWIK_CORE_BUILD constants"
      pattern: "IS_SERVER|IS_BROWSER|IS_DEV|QWIK_CORE_BUILD"
    - from: "optimizer/src/const_replace.rs"
      to: "optimizer/src/transform.rs"
      via: "use of ImportTracker for get_imported_local"
      pattern: "ImportTracker|get_imported_local"
---

<objective>
Create ConstReplacerVisitor module that replaces isServer/isBrowser/isDev identifiers with boolean literals.

Purpose: Enables bundlers to perform dead code elimination on server/client conditional code after the optimizer replaces these constants with their build-time values.

Output: const_replace.rs module with ConstReplacerVisitor implementing VisitMut for expression replacement.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ssr-build-modes/08-RESEARCH.md
@.planning/phases/08-ssr-build-modes/08-01-SUMMARY.md

# Reference SWC implementation
@qwik-core/src/optimizer/core/src/const_replace.rs

# OXC infrastructure
@optimizer/src/transform.rs
@optimizer/src/component/shared.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create const_replace.rs module</name>
  <files>optimizer/src/const_replace.rs, optimizer/src/lib.rs</files>
  <action>
Create a new file optimizer/src/const_replace.rs implementing the const replacement visitor.

```rust
//! Const replacement for SSR/build mode identifiers.
//!
//! Replaces `isServer`, `isBrowser`, and `isDev` identifiers with their
//! boolean literal values based on build configuration. This enables
//! bundlers (Vite/Rollup) to perform dead code elimination on conditional
//! server/client code.
//!
//! Example transformation (is_server=true):
//! ```js
//! // Input
//! import { isServer } from '@qwik.dev/core/build';
//! if (isServer) { serverOnlyCode(); }
//!
//! // Output
//! if (true) { serverOnlyCode(); }
//! // Bundler then eliminates: { serverOnlyCode(); }
//! ```

use crate::component::shared::{IS_BROWSER, IS_DEV, IS_SERVER, QWIK_CORE_BUILD, QWIK_CORE_SOURCE};
use crate::transform::ImportTracker;
use oxc_ast::ast;
use oxc_ast_visit::VisitMut;
use oxc_span::SPAN;

/// Which constant variable is being replaced
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ConstVariable {
    IsServer,
    IsBrowser,
    IsDev,
    None,
}

/// Visitor that replaces isServer/isBrowser/isDev identifiers with boolean literals.
///
/// Tracks which local identifiers map to the build constants (handling aliased imports)
/// and replaces them with the appropriate boolean value.
pub struct ConstReplacerVisitor {
    /// Whether this is a server build
    pub is_server: bool,
    /// Whether this is a development build
    pub is_dev: bool,
    /// Local identifier for isServer from @qwik.dev/core/build
    is_server_ident: Option<String>,
    /// Local identifier for isBrowser from @qwik.dev/core/build
    is_browser_ident: Option<String>,
    /// Local identifier for isDev from @qwik.dev/core/build
    is_dev_ident: Option<String>,
    /// Local identifier for isServer from @qwik.dev/core
    is_core_server_ident: Option<String>,
    /// Local identifier for isBrowser from @qwik.dev/core
    is_core_browser_ident: Option<String>,
    /// Local identifier for isDev from @qwik.dev/core
    is_core_dev_ident: Option<String>,
}

impl ConstReplacerVisitor {
    /// Create a new ConstReplacerVisitor.
    ///
    /// # Arguments
    /// * `is_server` - Whether this is a server build (true) or client build (false)
    /// * `is_dev` - Whether this is a development build
    /// * `import_tracker` - Tracks imported identifiers for finding aliased imports
    pub fn new(is_server: bool, is_dev: bool, import_tracker: &ImportTracker) -> Self {
        Self {
            is_server,
            is_dev,
            // Check @qwik.dev/core/build imports
            is_server_ident: import_tracker
                .get_imported_local(IS_SERVER, QWIK_CORE_BUILD)
                .cloned(),
            is_browser_ident: import_tracker
                .get_imported_local(IS_BROWSER, QWIK_CORE_BUILD)
                .cloned(),
            is_dev_ident: import_tracker
                .get_imported_local(IS_DEV, QWIK_CORE_BUILD)
                .cloned(),
            // Check @qwik.dev/core imports (both sources are valid)
            is_core_server_ident: import_tracker
                .get_imported_local(IS_SERVER, QWIK_CORE_SOURCE)
                .cloned(),
            is_core_browser_ident: import_tracker
                .get_imported_local(IS_BROWSER, QWIK_CORE_SOURCE)
                .cloned(),
            is_core_dev_ident: import_tracker
                .get_imported_local(IS_DEV, QWIK_CORE_SOURCE)
                .cloned(),
        }
    }

    /// Check if an identifier name matches any tracked const variable.
    fn match_ident(&self, name: &str) -> ConstVariable {
        // Check @qwik.dev/core/build imports
        if self.is_server_ident.as_deref() == Some(name) {
            return ConstVariable::IsServer;
        }
        if self.is_browser_ident.as_deref() == Some(name) {
            return ConstVariable::IsBrowser;
        }
        if self.is_dev_ident.as_deref() == Some(name) {
            return ConstVariable::IsDev;
        }
        // Check @qwik.dev/core imports
        if self.is_core_server_ident.as_deref() == Some(name) {
            return ConstVariable::IsServer;
        }
        if self.is_core_browser_ident.as_deref() == Some(name) {
            return ConstVariable::IsBrowser;
        }
        if self.is_core_dev_ident.as_deref() == Some(name) {
            return ConstVariable::IsDev;
        }
        ConstVariable::None
    }
}

impl<'a> VisitMut<'a> for ConstReplacerVisitor {
    fn visit_expression(&mut self, node: &mut ast::Expression<'a>) {
        // Check if this expression is an identifier that should be replaced
        let const_var = match node {
            ast::Expression::Identifier(ident) => self.match_ident(&ident.name),
            _ => ConstVariable::None,
        };

        match const_var {
            ConstVariable::IsServer => {
                // Replace with boolean literal for is_server
                *node = ast::Expression::BooleanLiteral(Box::new(ast::BooleanLiteral {
                    span: SPAN,
                    value: self.is_server,
                }));
            }
            ConstVariable::IsBrowser => {
                // Replace with boolean literal for !is_server (isBrowser is inverse)
                *node = ast::Expression::BooleanLiteral(Box::new(ast::BooleanLiteral {
                    span: SPAN,
                    value: !self.is_server,
                }));
            }
            ConstVariable::IsDev => {
                // Replace with boolean literal for is_dev
                *node = ast::Expression::BooleanLiteral(Box::new(ast::BooleanLiteral {
                    span: SPAN,
                    value: self.is_dev,
                }));
            }
            ConstVariable::None => {
                // Not a const variable - visit children
                oxc_ast_visit::walk_mut::walk_expression(self, node);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oxc_allocator::Allocator;
    use oxc_codegen::Codegen;
    use oxc_parser::Parser;
    use oxc_span::SourceType;

    fn replace_consts(code: &str, is_server: bool, is_dev: bool) -> String {
        let allocator = Allocator::default();
        let source_type = SourceType::tsx();
        let parse_result = Parser::new(&allocator, code, source_type).parse();
        assert!(
            parse_result.errors.is_empty(),
            "Parse errors: {:?}",
            parse_result.errors
        );

        let mut program = parse_result.program;

        // Build import tracker from the parsed program
        let mut import_tracker = ImportTracker::new();
        for stmt in &program.body {
            if let ast::Statement::ImportDeclaration(import) = stmt {
                let source = import.source.value.to_string();
                if let Some(specifiers) = &import.specifiers {
                    for specifier in specifiers {
                        if let ast::ImportDeclarationSpecifier::ImportSpecifier(spec) = specifier {
                            let imported = spec.imported.name().to_string();
                            let local = spec.local.name.to_string();
                            import_tracker.add_import(&source, &imported, &local);
                        }
                    }
                }
            }
        }

        let mut visitor = ConstReplacerVisitor::new(is_server, is_dev, &import_tracker);
        visitor.visit_program(&mut program);

        Codegen::default().build(&program).code
    }

    #[test]
    fn test_is_server_replacement_true() {
        let code = r#"
import { isServer } from '@qwik.dev/core/build';
if (isServer) { console.log('server'); }
"#;
        let output = replace_consts(code, true, false);
        assert!(output.contains("if (true)"), "Expected 'true', got: {}", output);
    }

    #[test]
    fn test_is_server_replacement_false() {
        let code = r#"
import { isServer } from '@qwik.dev/core/build';
if (isServer) { console.log('server'); }
"#;
        let output = replace_consts(code, false, false);
        assert!(output.contains("if (false)"), "Expected 'false', got: {}", output);
    }

    #[test]
    fn test_is_browser_replacement() {
        let code = r#"
import { isBrowser } from '@qwik.dev/core/build';
if (isBrowser) { console.log('browser'); }
"#;
        // isBrowser is !isServer, so when is_server=true, isBrowser=false
        let output = replace_consts(code, true, false);
        assert!(output.contains("if (false)"), "Expected 'false' (isBrowser when server), got: {}", output);

        // When is_server=false, isBrowser=true
        let output = replace_consts(code, false, false);
        assert!(output.contains("if (true)"), "Expected 'true' (isBrowser when client), got: {}", output);
    }

    #[test]
    fn test_is_dev_replacement() {
        let code = r#"
import { isDev } from '@qwik.dev/core/build';
if (isDev) { console.log('dev'); }
"#;
        let output = replace_consts(code, true, true);
        assert!(output.contains("if (true)"), "Expected 'true' (isDev=true), got: {}", output);

        let output = replace_consts(code, true, false);
        assert!(output.contains("if (false)"), "Expected 'false' (isDev=false), got: {}", output);
    }

    #[test]
    fn test_aliased_import() {
        let code = r#"
import { isServer as s } from '@qwik.dev/core/build';
if (s) { console.log('server'); }
"#;
        let output = replace_consts(code, true, false);
        assert!(output.contains("if (true)"), "Expected aliased 'isServer as s' to be replaced, got: {}", output);
    }

    #[test]
    fn test_qwik_core_source() {
        // isServer can also be imported from @qwik.dev/core
        let code = r#"
import { isServer } from '@qwik.dev/core';
if (isServer) { console.log('server'); }
"#;
        let output = replace_consts(code, true, false);
        assert!(output.contains("if (true)"), "Expected @qwik.dev/core import to work, got: {}", output);
    }

    #[test]
    fn test_multiple_consts() {
        let code = r#"
import { isServer, isBrowser, isDev } from '@qwik.dev/core/build';
const a = isServer;
const b = isBrowser;
const c = isDev;
"#;
        let output = replace_consts(code, true, true);
        // is_server=true -> isServer=true, isBrowser=false
        // is_dev=true -> isDev=true
        assert!(output.contains("const a = true"), "isServer should be true");
        assert!(output.contains("const b = false"), "isBrowser should be false");
        assert!(output.contains("const c = true"), "isDev should be true");
    }

    #[test]
    fn test_non_imported_identifier_unchanged() {
        // If isServer is not imported, it shouldn't be replaced
        let code = r#"
const isServer = false;
if (isServer) { console.log('local var'); }
"#;
        let output = replace_consts(code, true, false);
        // Should remain as local variable reference, not replaced
        assert!(output.contains("isServer"), "Local isServer should not be replaced");
    }
}
```

Then add the module to lib.rs:

```rust
// Add after existing module declarations
pub mod const_replace;
```
  </action>
  <verify>Run `cargo test const_replace` - all const_replace tests should pass</verify>
  <done>const_replace.rs module exists with ConstReplacerVisitor and 8 passing unit tests</done>
</task>

<task type="auto">
  <name>Task 2: Verify ConstReplacerVisitor handles edge cases</name>
  <files>optimizer/src/const_replace.rs</files>
  <action>
Add additional tests to const_replace.rs to verify edge cases from the research pitfalls:

```rust
#[test]
fn test_nested_expression() {
    // isServer in nested expression context
    let code = r#"
import { isServer } from '@qwik.dev/core/build';
const x = isServer ? 'server' : 'client';
"#;
    let output = replace_consts(code, true, false);
    assert!(output.contains("true ?"), "Ternary condition should have true, got: {}", output);
}

#[test]
fn test_logical_expression() {
    let code = r#"
import { isServer, isDev } from '@qwik.dev/core/build';
const x = isServer && isDev;
"#;
    let output = replace_consts(code, true, true);
    assert!(output.contains("true && true"), "Both should be true, got: {}", output);
}

#[test]
fn test_both_import_sources() {
    // Test that both @qwik.dev/core and @qwik.dev/core/build work together
    let code = r#"
import { isServer } from '@qwik.dev/core';
import { isDev } from '@qwik.dev/core/build';
const a = isServer;
const b = isDev;
"#;
    let output = replace_consts(code, true, true);
    assert!(output.contains("const a = true"), "isServer from core should work");
    assert!(output.contains("const b = true"), "isDev from core/build should work");
}

#[test]
fn test_no_replacement_without_import() {
    // Variables with same names but not imported should not be replaced
    let code = r#"
function test() {
    const isServer = computeIsServer();
    const isBrowser = !isServer;
    return { isServer, isBrowser };
}
"#;
    let output = replace_consts(code, true, false);
    // These are local variables, not imports - should remain unchanged
    assert!(output.contains("computeIsServer()"), "Local variables should not be touched");
}
```

Run the tests to verify all edge cases pass.
  </action>
  <verify>Run `cargo test const_replace` - all 12 tests should pass</verify>
  <done>ConstReplacerVisitor handles all edge cases: nested expressions, logical expressions, both sources, no false replacement</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cargo build` compiles successfully
2. `cargo test const_replace` - all const_replace module tests pass
3. `cargo test` - all 177+ tests pass
4. ConstReplacerVisitor correctly replaces:
   - isServer -> is_server value
   - isBrowser -> !is_server value
   - isDev -> is_dev value
5. Aliased imports handled correctly
6. Both @qwik.dev/core and @qwik.dev/core/build sources work
</verification>

<success_criteria>
- const_replace.rs module exists and exports ConstReplacerVisitor
- isServer replaced with is_server boolean literal
- isBrowser replaced with !is_server (inverse)
- isDev replaced with is_dev boolean literal
- Aliased imports work (import { isServer as s })
- Non-imported identifiers with same names not replaced
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-ssr-build-modes/08-02-SUMMARY.md`
</output>
