---
phase: 08-ssr-build-modes
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - optimizer/src/transform.rs
autonomous: true

must_haves:
  truths:
    - "Const replacement runs after import collection, before QRL transformation"
    - "Const replacement skipped in Test mode (matching SWC behavior)"
    - "Server build (is_server=true) replaces isServer with true"
    - "Client build (is_server=false) replaces isServer with false"
    - "Development build (target=Dev) replaces isDev with true"
    - "Production build (target=Prod) replaces isDev with false"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Integrated const replacement in transform pipeline"
      contains: "ConstReplacerVisitor"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "optimizer/src/const_replace.rs"
      via: "use and instantiation of ConstReplacerVisitor"
      pattern: "ConstReplacerVisitor::new"
---

<objective>
Integrate ConstReplacerVisitor into the transformation pipeline and add comprehensive integration tests.

Purpose: Enables end-to-end SSR/build mode transformations where isServer/isBrowser/isDev are replaced with their build-time values, allowing bundlers to eliminate dead code branches.

Output: Working const replacement in the transform pipeline with integration tests verifying all SSR requirements (SSR-01 through SSR-05).
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ssr-build-modes/08-RESEARCH.md
@.planning/phases/08-ssr-build-modes/08-01-SUMMARY.md
@.planning/phases/08-ssr-build-modes/08-02-SUMMARY.md

# Reference SWC implementation for integration pattern
@qwik-core/src/optimizer/core/src/parse.rs

# Files to modify
@optimizer/src/transform.rs
@optimizer/src/const_replace.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate const replacement into transform pipeline</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Integrate the ConstReplacerVisitor into the main transform function. The const replacement should run:
1. AFTER import collection (so we know which identifiers are imported)
2. BEFORE QRL transformation (so the replaced booleans are visible during QRL processing)
3. ONLY when NOT in Test mode (matching SWC behavior)

Update the transform() function (around line 2778):

1. Add import at top of file:
```rust
use crate::const_replace::ConstReplacerVisitor;
use crate::component::shared::Target;
use oxc_ast_visit::VisitMut;
```

2. In the transform() function, after the TransformGenerator is created but before traverse_mut, add const replacement:

```rust
pub fn transform(script_source: Source, options: TransformOptions) -> Result<OptimizationResult> {
    let allocator = Allocator::default();
    let source_text = script_source.source_code();
    let source_info = script_source.source_info();
    let source_type = script_source.source_info().try_into()?;

    let mut errors = Vec::new();

    let parse_return = Parser::new(&allocator, source_text, source_type).parse();
    errors.extend(parse_return.errors);

    let mut program = parse_return.program;

    if (options.transpile_ts) {
        let SemanticBuilderReturn {
            semantic,
            errors: semantic_errors,
        } = SemanticBuilder::new().build(&program);
        let scoping = semantic.into_scoping();
        Transformer::new(
            &allocator,
            source_info.rel_path.as_path(),
            &OxcTransformOptions {
                typescript: TypeScriptOptions::default(),
                jsx: JsxOptions::disable(),
                ..OxcTransformOptions::default()
            },
        )
        .build_with_scoping(scoping, &mut program);
    }

    // Collect imports BEFORE const replacement
    // Build an ImportTracker from the program's import declarations
    let mut import_tracker = ImportTracker::new();
    for stmt in &program.body {
        if let Statement::ImportDeclaration(import) = stmt {
            let source = import.source.value.to_string();
            if let Some(specifiers) = &import.specifiers {
                for specifier in specifiers {
                    match specifier {
                        ImportDeclarationSpecifier::ImportSpecifier(spec) => {
                            let imported = spec.imported.name().to_string();
                            let local = spec.local.name.to_string();
                            import_tracker.add_import(&source, &imported, &local);
                        }
                        ImportDeclarationSpecifier::ImportDefaultSpecifier(spec) => {
                            let local = spec.local.name.to_string();
                            import_tracker.add_import(&source, "default", &local);
                        }
                        ImportDeclarationSpecifier::ImportNamespaceSpecifier(spec) => {
                            let local = spec.local.name.to_string();
                            import_tracker.add_import(&source, "*", &local);
                        }
                    }
                }
            }
        }
    }

    // Apply const replacement (skip in Test mode to match SWC behavior)
    if options.target != Target::Test {
        let mut const_replacer = ConstReplacerVisitor::new(
            options.is_server,
            options.is_dev(),
            &import_tracker,
        );
        const_replacer.visit_program(&mut program);
    }

    let SemanticBuilderReturn {
        semantic,
        errors: semantic_errors,
    } = SemanticBuilder::new()
        .with_check_syntax_error(true)
        .with_cfg(true)
        .build(&program);

    let mut transform = TransformGenerator::new(source_info, options, None, &allocator);

    let scoping = semantic.into_scoping();

    traverse_mut(&mut transform, &allocator, &mut program, scoping, ());

    let TransformGenerator { app, errors, .. } = transform;
    Ok(OptimizationResult::new(app, errors))
}
```

Note: The ImportDeclarationSpecifier imports need to be added:
```rust
use oxc_ast::ast::{ImportDeclarationSpecifier, ...};
```
  </action>
  <verify>Run `cargo build` - should compile. Run `cargo test` - all existing tests should pass</verify>
  <done>ConstReplacerVisitor integrated into transform pipeline, runs after imports collected, skips Test mode</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for SSR requirements</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add integration tests to the tests module in transform.rs that verify all SSR requirements:

```rust
// Add these tests to the existing tests module in transform.rs

#[test]
fn test_ssr_01_is_server_replacement_server_build() {
    // SSR-01: isServer const replacement - server build
    let code = r#"
import { isServer } from '@qwik.dev/core/build';
export const serverCheck = isServer;
"#;
    let source = Source::new(code, "test.tsx");
    let options = TransformOptions::default()
        .with_transpile_jsx(true)
        .with_is_server(true);
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // isServer should be replaced with true for server build
    assert!(
        output.contains("= true"),
        "SSR-01: isServer should be 'true' in server build, got: {}",
        output
    );
}

#[test]
fn test_ssr_01_is_server_replacement_client_build() {
    // SSR-01: isServer const replacement - client build
    let code = r#"
import { isServer } from '@qwik.dev/core/build';
export const serverCheck = isServer;
"#;
    let source = Source::new(code, "test.tsx");
    let options = TransformOptions::default()
        .with_transpile_jsx(true)
        .with_is_server(false);
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // isServer should be replaced with false for client build
    assert!(
        output.contains("= false"),
        "SSR-01: isServer should be 'false' in client build, got: {}",
        output
    );
}

#[test]
fn test_ssr_02_is_dev_replacement_dev_mode() {
    // SSR-02: isDev const replacement - dev mode
    let code = r#"
import { isDev } from '@qwik.dev/core/build';
export const devCheck = isDev;
"#;
    let source = Source::new(code, "test.tsx");
    let mut options = TransformOptions::default().with_transpile_jsx(true);
    options.target = Target::Dev;  // Dev mode
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // isDev should be replaced with true for dev mode
    assert!(
        output.contains("= true"),
        "SSR-02: isDev should be 'true' in dev mode, got: {}",
        output
    );
}

#[test]
fn test_ssr_02_is_dev_replacement_prod_mode() {
    // SSR-02: isDev const replacement - prod mode
    let code = r#"
import { isDev } from '@qwik.dev/core/build';
export const devCheck = isDev;
"#;
    let source = Source::new(code, "test.tsx");
    let mut options = TransformOptions::default().with_transpile_jsx(true);
    options.target = Target::Prod;  // Prod mode
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // isDev should be replaced with false for prod mode
    assert!(
        output.contains("= false"),
        "SSR-02: isDev should be 'false' in prod mode, got: {}",
        output
    );
}

#[test]
fn test_ssr_03_server_only_code_marked_for_elimination() {
    // SSR-03: Server-only code can be eliminated by bundler
    // The optimizer replaces constants; bundler does DCE
    let code = r#"
import { isServer } from '@qwik.dev/core/build';
if (isServer) {
    serverOnlyFunction();
}
"#;
    let source = Source::new(code, "test.tsx");
    let options = TransformOptions::default()
        .with_transpile_jsx(true)
        .with_is_server(false);  // Client build
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // isServer replaced with false makes if(false) { ... } which bundler can eliminate
    assert!(
        output.contains("if (false)"),
        "SSR-03: Server-only code should have 'if (false)' for bundler DCE, got: {}",
        output
    );
}

#[test]
fn test_ssr_04_client_only_code_marked_for_elimination() {
    // SSR-04: Client-only code can be eliminated by bundler
    let code = r#"
import { isBrowser } from '@qwik.dev/core/build';
if (isBrowser) {
    clientOnlyFunction();
}
"#;
    let source = Source::new(code, "test.tsx");
    let options = TransformOptions::default()
        .with_transpile_jsx(true)
        .with_is_server(true);  // Server build
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // isBrowser replaced with false makes if(false) { ... } which bundler can eliminate
    assert!(
        output.contains("if (false)"),
        "SSR-04: Client-only code should have 'if (false)' for bundler DCE, got: {}",
        output
    );
}

#[test]
fn test_ssr_05_mode_specific_combined() {
    // SSR-05: Mode-specific transformations (combined test)
    let code = r#"
import { isServer, isBrowser, isDev } from '@qwik.dev/core/build';
const server = isServer;
const browser = isBrowser;
const dev = isDev;
"#;
    let source = Source::new(code, "test.tsx");
    let mut options = TransformOptions::default().with_transpile_jsx(true);
    options.target = Target::Dev;
    options.is_server = true;
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // Server + Dev mode: isServer=true, isBrowser=false, isDev=true
    assert!(
        output.contains("server = true"),
        "SSR-05: isServer should be true, got: {}",
        output
    );
    assert!(
        output.contains("browser = false"),
        "SSR-05: isBrowser should be false (inverse of isServer), got: {}",
        output
    );
    assert!(
        output.contains("dev = true"),
        "SSR-05: isDev should be true in Dev mode, got: {}",
        output
    );
}

#[test]
fn test_ssr_skip_in_test_mode() {
    // Const replacement should be skipped in Test mode (matching SWC behavior)
    let code = r#"
import { isServer } from '@qwik.dev/core/build';
export const serverCheck = isServer;
"#;
    let source = Source::new(code, "test.tsx");
    let mut options = TransformOptions::default().with_transpile_jsx(true);
    options.target = Target::Test;
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    // In Test mode, isServer should NOT be replaced - remains as identifier
    assert!(
        output.contains("isServer") && !output.contains("= true") && !output.contains("= false"),
        "In Test mode, const replacement should be skipped, got: {}",
        output
    );
}

#[test]
fn test_ssr_aliased_import() {
    // Aliased imports should work
    let code = r#"
import { isServer as s, isBrowser as b } from '@qwik.dev/core/build';
const x = s;
const y = b;
"#;
    let source = Source::new(code, "test.tsx");
    let options = TransformOptions::default()
        .with_transpile_jsx(true)
        .with_is_server(true);
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    assert!(
        output.contains("x = true"),
        "Aliased isServer should be replaced, got: {}",
        output
    );
    assert!(
        output.contains("y = false"),
        "Aliased isBrowser should be replaced, got: {}",
        output
    );
}

#[test]
fn test_ssr_qwik_core_source() {
    // isServer can be imported from @qwik.dev/core (not just /build)
    let code = r#"
import { isServer } from '@qwik.dev/core';
export const check = isServer;
"#;
    let source = Source::new(code, "test.tsx");
    let options = TransformOptions::default()
        .with_transpile_jsx(true)
        .with_is_server(true);
    let result = transform(source, options).expect("transform failed");
    let output = result.code_string();

    assert!(
        output.contains("= true"),
        "isServer from @qwik.dev/core should be replaced, got: {}",
        output
    );
}
```

Make sure the test module has access to Target:
```rust
use crate::component::shared::Target;
```
  </action>
  <verify>Run `cargo test ssr` - all SSR integration tests should pass</verify>
  <done>10 integration tests covering SSR-01 through SSR-05, plus edge cases (Test mode skip, aliased imports, both sources)</done>
</task>

<task type="auto">
  <name>Task 3: Verify all tests pass and document requirements</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Run the full test suite and verify all requirements are satisfied:

1. Run `cargo test` to ensure all 177+ tests pass
2. Run `cargo test ssr` to verify SSR-specific tests
3. Run `cargo test const_replace` to verify unit tests

Add a documentation comment at the top of const_replace.rs summarizing the requirements covered:

```rust
//! # SSR & Build Mode Const Replacement
//!
//! This module implements const replacement for SSR/build mode identifiers,
//! satisfying the following requirements:
//!
//! - **SSR-01**: isServer const replaced correctly based on build target
//! - **SSR-02**: isDev const replaced correctly based on build mode
//! - **SSR-03**: Server-only code marked for elimination (if(false) pattern)
//! - **SSR-04**: Client-only code marked for elimination (if(false) pattern)
//! - **SSR-05**: Mode-specific transformations apply correctly
//!
//! ## How It Works
//!
//! 1. Imports are collected to track which local identifiers map to isServer/isBrowser/isDev
//! 2. ConstReplacerVisitor replaces those identifiers with boolean literals
//! 3. Downstream bundler (Vite/Rollup) performs dead code elimination on if(true)/if(false)
//!
//! ## Configuration
//!
//! - `TransformOptions.is_server`: true for server build, false for client build
//! - `TransformOptions.target`: Dev/Prod/Lib/Test - affects isDev value
//! - Const replacement is skipped in Test mode (matching SWC behavior)
```
  </action>
  <verify>Run `cargo test` - all tests pass. Count should be 187+ (177 existing + 10 SSR + const_replace unit tests)</verify>
  <done>All tests pass, requirements SSR-01 through SSR-05 documented and verified</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cargo build` compiles successfully
2. `cargo test` - all tests pass (187+ total)
3. `cargo test ssr` - all 10 SSR integration tests pass
4. `cargo test const_replace` - all unit tests pass
5. SSR-01: isServer replacement verified for server and client builds
6. SSR-02: isDev replacement verified for Dev and Prod modes
7. SSR-03: Server-only code has if(false) pattern for DCE
8. SSR-04: Client-only code has if(false) pattern for DCE
9. SSR-05: Combined mode-specific transformations work
10. Test mode skips const replacement
</verification>

<success_criteria>
- ConstReplacerVisitor integrated into transform pipeline
- Const replacement runs after import collection, before QRL transformation
- Const replacement skipped in Test mode
- SSR-01 through SSR-05 all satisfied with passing tests
- Total test count: 187+ (177 existing + 10 SSR integration + const_replace unit tests)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-ssr-build-modes/08-03-SUMMARY.md`
</output>
