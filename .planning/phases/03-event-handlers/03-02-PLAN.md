---
phase: 03-event-handlers
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - optimizer/src/transform.rs
autonomous: true

must_haves:
  truths:
    - "Event handlers on native elements get on:* attribute names"
    - "Event handlers on component elements keep onClick$ attribute names"
    - "Event handler arrow functions transform to QRL calls"
    - "Capture arrays are included in QRL for event handlers with captured variables"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Native element tracking and event handler QRL transformation"
      contains: "jsx_element_is_native"
  key_links:
    - from: "exit_jsx_attribute"
      to: "jsx_event_to_html_attribute"
      via: "attribute name transformation"
      pattern: "jsx_event_to_html_attribute"
    - from: "enter_jsx_attribute"
      to: "qrl_stack"
      via: "QRL context setup for event handlers"
      pattern: "import_stack.push"
---

<objective>
Implement native element detection and extend JSX attribute handling to transform event handlers into QRL calls.

Purpose: Event handlers like `onClick$={() => {}}` on native elements must transform to `on:click={qrl(...)}`. This is the core integration that connects Phase 3 to Phase 2's QRL infrastructure.

Output: Working event handler transformation in JSX attributes.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-event-handlers/03-RESEARCH.md
@.planning/phases/03-event-handlers/03-01-SUMMARY.md
@optimizer/src/transform.rs
@optimizer/src/component/qrl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add native element tracking stack</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add a new field to `TransformGenerator` to track whether each JSX element in the stack is a native HTML element.

1. Add field to `TransformGenerator` struct (after `decl_stack`):

```rust
/// Stack tracking whether each JSX element is a native HTML element.
/// Native elements (lowercase first char like `<div>`, `<button>`) get event name transformation.
/// Component elements (uppercase first char like `<MyButton>`) keep original attribute names.
jsx_element_is_native: Vec<bool>,
```

2. Initialize in `TransformGenerator::new`:

```rust
jsx_element_is_native: Vec::new(),
```

3. Update `enter_jsx_element` to push native detection at the START of the method:

```rust
fn enter_jsx_element(&mut self, node: &mut JSXElement<'a>, ctx: &mut TraverseCtx<'a, ()>) {
    // Determine if this is a native element (lowercase first char)
    let is_native = match &node.opening_element.name {
        JSXElementName::Identifier(_) => true,  // lowercase native HTML
        JSXElementName::IdentifierReference(id) => {
            id.name.chars().next().map(|c| c.is_ascii_lowercase()).unwrap_or(false)
        }
        JSXElementName::MemberExpression(_) => false,  // Foo.Bar = component
        JSXElementName::NamespacedName(_) => true,     // svg:rect = native
        JSXElementName::ThisExpression(_) => false,    // this = component
    };
    self.jsx_element_is_native.push(is_native);

    // ... rest of existing enter_jsx_element code ...
```

4. Update `exit_jsx_element` to pop BEFORE the descend call:

```rust
fn exit_jsx_element(&mut self, node: &mut JSXElement<'a>, ctx: &mut TraverseCtx<'a, ()>) {
    // ... existing code ...

    // Pop native element tracking
    self.jsx_element_is_native.pop();

    self.debug("EXIT: JSXElementName", ctx);
    self.descend();
}
```
  </action>
  <verify>
Run: `cargo check -p optimizer`
Expect: Compiles without errors
  </verify>
  <done>Native element tracking stack added and maintained during JSX traversal</done>
</task>

<task type="auto">
  <name>Task 2: Transform event handler attribute names on native elements</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add attribute name transformation for event handlers in `exit_jsx_attribute`. This task ONLY handles the name transformation (onClick$ -> on:click). The QRL transformation for the function value is handled separately.

Locate `exit_jsx_attribute` and add AT THE BEGINNING, before the `transpile_jsx` check:

```rust
fn exit_jsx_attribute(&mut self, node: &mut JSXAttribute<'a>, ctx: &mut TraverseCtx<'a, ()>) {
    // Transform event handler attribute names on native elements
    let attr_name = node.name.get_identifier().map(|id| id.name.as_str()).unwrap_or("");

    if attr_name.ends_with(MARKER_SUFFIX) {
        let is_native = self.jsx_element_is_native.last().copied().unwrap_or(false);

        if is_native {
            if let Some(html_attr) = jsx_event_to_html_attribute(attr_name) {
                let new_name = self.builder.atom(&html_attr);
                node.name = JSXAttributeName::Identifier(
                    self.builder.alloc(JSXIdentifier {
                        span: node.name.span(),
                        name: new_name,
                    })
                );
            }
        }
    }

    // ... existing transpile_jsx handling continues below ...
    if self.options.transpile_jsx {
```

Note: This ONLY transforms the attribute NAME. The QRL transformation for function values is already handled by the existing `exit_jsx_attribute_value` when there's a QRL on the stack, or needs to be triggered via enter_jsx_attribute (Task 3).
  </action>
  <verify>
Run: `cargo check -p optimizer`
Expect: Compiles without errors
  </verify>
  <done>Event handler attribute names transform on native elements (onClick$ -> on:click)</done>
</task>

<task type="auto">
  <name>Task 3: Set up QRL context for event handler functions</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Integrate with the existing QRL infrastructure by setting up context in `enter_jsx_attribute` so that the arrow function inside gets properly transformed.

The existing flow is:
1. `enter_call_expression` detects marker functions (`$` suffix) and pushes to import_stack
2. `exit_call_expression` creates QrlComponent and pushes to qrl_stack
3. `exit_jsx_attribute_value` pops from qrl_stack and replaces expression

For JSX attributes like `onClick$={() => {}}`, there is NO call expression - the attribute value is directly a function. We need to trigger the same flow by detecting the pattern in `enter_jsx_attribute`.

Add to `enter_jsx_attribute`, AFTER the existing segment_stack.push:

```rust
fn enter_jsx_attribute(&mut self, node: &mut JSXAttribute<'a>, ctx: &mut TraverseCtx<'a, ()>) {
    // ... existing code that pushes to segment_stack ...

    // Check if this is an event handler attribute with a function value
    let attr_name = node.name.get_identifier().map(|id| id.name.as_str()).unwrap_or("");

    if attr_name.ends_with(MARKER_SUFFIX) {
        if let Some(JSXAttributeValue::ExpressionContainer(container)) = &node.value {
            if let JSXExpression::Expression(expr) = &container.expression {
                let is_fn = matches!(
                    &**expr,
                    Expression::ArrowFunctionExpression(_) | Expression::FunctionExpression(_)
                );

                if is_fn {
                    // Push new import stack frame for this QRL (mirrors enter_call_expression)
                    self.import_stack.push(BTreeSet::new());
                }
            }
        }
    }
}
```

Then update `exit_jsx_attribute` to handle the QRL transformation when the attribute has a function value. Add AFTER the name transformation code from Task 2, but BEFORE transpile_jsx:

```rust
    // Handle QRL transformation for event handler function values
    if attr_name.ends_with(MARKER_SUFFIX) {
        if let Some(JSXAttributeValue::ExpressionContainer(container)) = &mut node.value {
            if let JSXExpression::Expression(expr) = &container.expression {
                let is_fn = matches!(
                    &**expr,
                    Expression::ArrowFunctionExpression(_) | Expression::FunctionExpression(_)
                );

                if is_fn {
                    // Create QRL using existing infrastructure (mirrors exit_call_expression)
                    // 1. Collect identifiers
                    let descendent_idents = {
                        use crate::collector::IdentCollector;
                        let mut collector = IdentCollector::new();
                        use oxc_ast_visit::Visit;
                        collector.visit_expression(expr);
                        collector.get_words()
                    };

                    // 2. Get declarations and compute captures
                    let all_decl: Vec<IdPlusType> = self.decl_stack.iter()
                        .flat_map(|v| v.iter()).cloned().collect();
                    let (decl_collect, _): (Vec<_>, Vec<_>) = all_decl.into_iter()
                        .partition(|(_, t)| matches!(t, IdentType::Var(_)));
                    let (scoped_idents, _) = compute_scoped_idents(&descendent_idents, &decl_collect);

                    // 3. Filter imported identifiers
                    let imports = self.import_stack.pop().unwrap_or_default();
                    let imported_names: HashSet<String> = imports.iter()
                        .flat_map(|import| import.names.iter())
                        .filter_map(|id| match id {
                            ImportId::Named(name) | ImportId::Default(name) => Some(name.clone()),
                            ImportId::NamedWithAlias(_, local) => Some(local.clone()),
                            ImportId::Namespace(_) => None,
                        }).collect();
                    let scoped_idents: Vec<Id> = scoped_idents.into_iter()
                        .filter(|(name, _)| !imported_names.contains(name)).collect();

                    // 4. Create Qrl and transform
                    let display_name = self.current_display_name();
                    let qrl = Qrl::new(
                        self.source_info.rel_path.clone(),
                        &display_name,
                        QrlType::Qrl,
                        scoped_idents,
                    );

                    let call_expr = qrl.into_call_expression(
                        ctx,
                        &mut self.symbol_by_name,
                        &mut self.import_by_symbol,
                    );

                    // 5. Replace expression with QRL call
                    container.expression = JSXExpression::from(
                        Expression::CallExpression(ctx.ast.alloc(call_expr))
                    );

                    // 6. Add qrl import
                    if let Some(import_set) = self.import_stack.last_mut() {
                        import_set.insert(Import::qrl());
                    }
                }
            }
        }
    }
```

Required imports at top of file (if not already present):
- `use std::collections::HashSet;`
  </action>
  <verify>
Run: `cargo test -p optimizer`
Expect: Tests pass, no regressions
  </verify>
  <done>Event handler functions transform to QRL calls via existing infrastructure</done>
</task>

<task type="auto">
  <name>Task 4: Add integration test for event handler transformation</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add an integration test that verifies event handler transformation end-to-end.

Add to the test module:

```rust
#[test]
fn test_event_handler_transformation() {
    use crate::source::Source;

    let source_code = r#"
import { component$ } from '@qwik.dev/core';

export const Button = component$(() => {
    return <button onClick$={() => console.log('clicked')}>Click</button>;
});
"#;

    let source = Source::from_string(source_code.to_string(), "test.tsx".into());
    let options = TransformOptions::default().with_transpile_jsx(true);
    let result = transform(source, options).expect("Transform should succeed");

    let output = &result.optimized_app.body;

    // Verify attribute name transformed
    assert!(output.contains("on:click") || output.contains("\"on:click\""),
        "Expected 'on:click' in output, got: {}", output);

    // Verify QRL is generated (should have qrl function call)
    assert!(output.contains("qrl(") || output.contains("qrl "),
        "Expected QRL call in output, got: {}", output);
}

#[test]
fn test_event_handler_on_component_no_name_transform() {
    use crate::source::Source;

    let source_code = r#"
import { component$ } from '@qwik.dev/core';
import { CustomButton } from './custom';

export const Parent = component$(() => {
    return <CustomButton onClick$={() => console.log('click')}/>;
});
"#;

    let source = Source::from_string(source_code.to_string(), "test.tsx".into());
    let options = TransformOptions::default().with_transpile_jsx(false);
    let result = transform(source, options).expect("Transform should succeed");

    let output = &result.optimized_app.body;

    // On components, attribute name should NOT transform to on:click
    assert!(!output.contains("on:click"),
        "Component should keep onClick$, not transform to on:click: {}", output);
}
```
  </action>
  <verify>
Run: `cargo test -p optimizer test_event_handler`
Expect: Tests pass
  </verify>
  <done>Integration tests verify event handler transformation works correctly</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cargo test -p optimizer

# Specific event handler test
cargo test -p optimizer test_event_handler

# Code compiles
cargo check -p optimizer
```
</verification>

<success_criteria>
1. `jsx_element_is_native` stack tracks native vs component elements correctly
2. Event handler attribute names transform on native elements (`onClick$` -> `on:click`)
3. Event handler attribute names preserved on components (`onClick$` stays `onClick$`)
4. Event handler functions create QRL call expressions
5. No regression in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-event-handlers/03-02-SUMMARY.md`
</output>
