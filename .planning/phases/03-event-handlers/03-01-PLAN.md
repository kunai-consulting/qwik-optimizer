---
phase: 03-event-handlers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/transform.rs
autonomous: true

must_haves:
  truths:
    - "onClick$ transforms to on:click"
    - "onDblClick$ transforms to on:dblclick"
    - "document:onFocus$ transforms to on-document:focus"
    - "window:onClick$ transforms to on-window:click"
    - "on-cLick$ transforms to on:c-lick (case preserved)"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Event name transformation utilities"
      exports: ["jsx_event_to_html_attribute", "get_event_scope_data_from_jsx_event"]
  key_links:
    - from: "jsx_event_to_html_attribute"
      to: "get_event_scope_data_from_jsx_event"
      via: "prefix extraction"
      pattern: "get_event_scope_data_from_jsx_event"
---

<objective>
Implement event name transformation utilities for converting Qwik JSX event attributes to HTML attribute format.

Purpose: Event handlers like `onClick$` must transform to `on:click` on native elements. This is the foundation for Phase 3 event handling, providing the string transformation logic independent of AST manipulation.

Output: Three utility functions in transform.rs with unit tests.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-event-handlers/03-RESEARCH.md
@optimizer/src/transform.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement event scope data extraction</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add the `get_event_scope_data_from_jsx_event` function near the other utility functions (around line 1370, after `is_text_only`).

This function extracts the prefix (on:, on-document:, on-window:) and the index where the event name begins.

```rust
/// Extracts scope prefix and event name start index from a JSX event attribute name.
///
/// # Returns
/// A tuple of (prefix, start_index) where:
/// - prefix: "on:", "on-document:", or "on-window:"
/// - start_index: index where the event name begins (after "on", "document:on", or "window:on")
/// - If not an event, returns ("", usize::MAX)
///
/// # Examples
/// - "onClick$" -> ("on:", 2)
/// - "document:onFocus$" -> ("on-document:", 11)
/// - "window:onClick$" -> ("on-window:", 9)
/// - "custom$" -> ("", usize::MAX)
fn get_event_scope_data_from_jsx_event(jsx_event: &str) -> (&'static str, usize) {
    if jsx_event.starts_with("window:on") {
        ("on-window:", 9)
    } else if jsx_event.starts_with("document:on") {
        ("on-document:", 11)
    } else if jsx_event.starts_with("on") {
        ("on:", 2)
    } else {
        ("", usize::MAX)
    }
}
```

Note: The prefix transformation follows SWC's pattern where:
- `onClick$` uses prefix `on:` (starts at index 2)
- `document:onFocus$` uses prefix `on-document:` (starts at index 11 = "document:on".len())
- `window:onClick$` uses prefix `on-window:` (starts at index 9 = "window:on".len())
  </action>
  <verify>
Run: `cargo check -p optimizer`
Expect: Code compiles without errors
  </verify>
  <done>Function `get_event_scope_data_from_jsx_event` exists and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement event name creation with case handling</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add the `create_event_name` function after `get_event_scope_data_from_jsx_event`.

This function converts camelCase event names to kebab-case for HTML attributes.

```rust
/// Creates an HTML event attribute name from an event name and prefix.
///
/// Converts camelCase to kebab-case (e.g., "Click" -> "click", "DblClick" -> "dblclick").
/// The `-` prefix in the original name preserves case (e.g., "-cLick" -> "c-lick").
///
/// # Examples
/// - ("click", "on:") -> "on:click"
/// - ("DblClick", "on:") -> "on:dblclick"
/// - ("Focus", "on-document:") -> "on-document:focus"
fn create_event_name(name: &str, prefix: &str) -> String {
    let mut result = String::from(prefix);

    // Check if name starts with '-' (case-preserving marker)
    let name = if let Some(stripped) = name.strip_prefix('-') {
        // Case-preserving: don't lowercase, but still convert camelCase humps to dashes
        for c in stripped.chars() {
            if c.is_ascii_uppercase() {
                result.push('-');
                result.push(c.to_ascii_lowercase());
            } else {
                result.push(c);
            }
        }
        return result;
    } else {
        name
    };

    // Standard camelCase to kebab-case: lowercase everything
    for c in name.chars() {
        if c.is_ascii_uppercase() {
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}
```

Key behavior:
- Standard events: `Click` -> `click`, `DblClick` -> `dblclick` (all lowercase)
- Case-preserving events: `-cLick` -> `c-lick` (preserves case with `-` separator)
  </action>
  <verify>
Run: `cargo check -p optimizer`
Expect: Code compiles without errors
  </verify>
  <done>Function `create_event_name` exists with camelCase to kebab-case conversion</done>
</task>

<task type="auto">
  <name>Task 3: Implement main jsx_event_to_html_attribute function and tests</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add the main `jsx_event_to_html_attribute` function that combines the utilities.

```rust
/// Transforms a Qwik JSX event attribute name to HTML attribute format.
///
/// Returns `None` if the attribute is not a valid event (doesn't end with '$'
/// or doesn't start with a valid event prefix).
///
/// # Examples
/// - "onClick$" -> Some("on:click")
/// - "onDblClick$" -> Some("on:dblclick")
/// - "document:onFocus$" -> Some("on-document:focus")
/// - "window:onClick$" -> Some("on-window:click")
/// - "on-cLick$" -> Some("on:c-lick") (case preserved due to '-' prefix)
/// - "onClick" -> None (no '$' suffix)
/// - "custom$" -> None (not an event)
fn jsx_event_to_html_attribute(jsx_event: &str) -> Option<String> {
    // Must end with '$' to be a Qwik event handler
    if !jsx_event.ends_with('$') {
        return None;
    }

    let (prefix, idx) = get_event_scope_data_from_jsx_event(jsx_event);
    if idx == usize::MAX {
        return None;
    }

    // Extract event name: strip '$' suffix and take from idx
    // e.g., "onClick$" with idx=2 -> "Click"
    let name = &jsx_event[idx..jsx_event.len() - 1];

    Some(create_event_name(name, prefix))
}
```

Then add unit tests to the existing `tests` module at the bottom of the file:

```rust
#[test]
fn test_jsx_event_to_html_attribute_basic() {
    assert_eq!(jsx_event_to_html_attribute("onClick$"), Some("on:click".to_string()));
    assert_eq!(jsx_event_to_html_attribute("onInput$"), Some("on:input".to_string()));
    assert_eq!(jsx_event_to_html_attribute("onDblClick$"), Some("on:dblclick".to_string()));
    assert_eq!(jsx_event_to_html_attribute("onKeyDown$"), Some("on:keydown".to_string()));
    assert_eq!(jsx_event_to_html_attribute("onMouseOver$"), Some("on:mouseover".to_string()));
    assert_eq!(jsx_event_to_html_attribute("onBlur$"), Some("on:blur".to_string()));
}

#[test]
fn test_jsx_event_to_html_attribute_document_window() {
    assert_eq!(jsx_event_to_html_attribute("document:onFocus$"), Some("on-document:focus".to_string()));
    assert_eq!(jsx_event_to_html_attribute("document:onClick$"), Some("on-document:click".to_string()));
    assert_eq!(jsx_event_to_html_attribute("window:onClick$"), Some("on-window:click".to_string()));
    assert_eq!(jsx_event_to_html_attribute("window:onScroll$"), Some("on-window:scroll".to_string()));
}

#[test]
fn test_jsx_event_to_html_attribute_case_preserving() {
    // The '-' prefix preserves case with dash separation at uppercase letters
    assert_eq!(jsx_event_to_html_attribute("on-cLick$"), Some("on:c-lick".to_string()));
    assert_eq!(jsx_event_to_html_attribute("on-anotherCustom$"), Some("on:another-custom".to_string()));
}

#[test]
fn test_jsx_event_to_html_attribute_not_event() {
    // No '$' suffix
    assert_eq!(jsx_event_to_html_attribute("onClick"), None);
    // Not starting with 'on' (after any scope prefix)
    assert_eq!(jsx_event_to_html_attribute("custom$"), None);
    // Empty or invalid
    assert_eq!(jsx_event_to_html_attribute("$"), None);
    assert_eq!(jsx_event_to_html_attribute(""), None);
}

#[test]
fn test_get_event_scope_data() {
    assert_eq!(get_event_scope_data_from_jsx_event("onClick$"), ("on:", 2));
    assert_eq!(get_event_scope_data_from_jsx_event("onInput$"), ("on:", 2));
    assert_eq!(get_event_scope_data_from_jsx_event("document:onFocus$"), ("on-document:", 11));
    assert_eq!(get_event_scope_data_from_jsx_event("window:onClick$"), ("on-window:", 9));
    assert_eq!(get_event_scope_data_from_jsx_event("custom$"), ("", usize::MAX));
}
```
  </action>
  <verify>
Run: `cargo test -p optimizer test_jsx_event`
Expect: All event transformation tests pass
  </verify>
  <done>All three functions implemented with passing unit tests</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cargo test -p optimizer test_jsx_event
cargo test -p optimizer test_get_event_scope

# Code compiles
cargo check -p optimizer
```
</verification>

<success_criteria>
1. `jsx_event_to_html_attribute("onClick$")` returns `Some("on:click")`
2. `jsx_event_to_html_attribute("document:onFocus$")` returns `Some("on-document:focus")`
3. `jsx_event_to_html_attribute("window:onClick$")` returns `Some("on-window:click")`
4. `jsx_event_to_html_attribute("on-cLick$")` returns `Some("on:c-lick")`
5. `jsx_event_to_html_attribute("custom$")` returns `None`
6. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-event-handlers/03-01-SUMMARY.md`
</output>
