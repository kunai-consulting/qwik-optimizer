---
phase: 11-research-code-cleanup
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - optimizer/src/transform/generator.rs
  - optimizer/src/transform/jsx.rs
  - optimizer/src/transform/mod.rs
autonomous: true

must_haves:
  truths:
    - "JSX-related helper functions are in a dedicated jsx.rs module"
    - "generator.rs impl Traverse uses dispatcher pattern for JSX methods"
    - "All 233 tests still pass"
  artifacts:
    - path: "optimizer/src/transform/jsx.rs"
      provides: "JSX transformation helpers"
      contains: "pub fn enter_jsx_element"
    - path: "optimizer/src/transform/generator.rs"
      provides: "TransformGenerator with thin Traverse impl"
      max_lines: 2000
  key_links:
    - from: "optimizer/src/transform/generator.rs"
      to: "optimizer/src/transform/jsx.rs"
      via: "jsx::enter_jsx_element(self, node, ctx)"
      pattern: "jsx::"
---

<objective>
Extract JSX transformation logic from generator.rs to a dedicated jsx.rs module using the dispatcher pattern.

Purpose: Apply the dispatcher pattern from 11-RESEARCH.md - keep impl Traverse in generator.rs as a thin dispatcher that delegates to domain-specific modules. JSX is the largest domain (~800 lines of logic).

Output: jsx.rs module with JSX helpers, generator.rs with dispatcher-style Traverse impl.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-research-code-cleanup/11-RESEARCH.md
@.planning/phases/11-research-code-cleanup/11-02-SUMMARY.md

# Source files
@optimizer/src/transform/generator.rs
@optimizer/src/transform/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create jsx.rs with helper functions</name>
  <files>optimizer/src/transform/jsx.rs, optimizer/src/transform/mod.rs</files>
  <action>
1. Create optimizer/src/transform/jsx.rs

2. Extract these functions from generator.rs to jsx.rs:
   - `jsx_event_to_html_attribute()` - event name transformation
   - `get_event_scope_data_from_jsx_event()` - event scope parsing
   - `create_event_name()` - camelCase to kebab-case
   - Any other JSX-specific utility functions (look for jsx_ prefix)

3. Create public helper functions that will be called from Traverse impl:
   ```rust
   pub fn enter_jsx_element<'a>(
       gen: &mut TransformGenerator<'a>,
       node: &mut JSXElement<'a>,
       ctx: &mut TraverseCtx<'a, ()>
   ) {
       // Move logic from TransformGenerator::enter_jsx_element here
   }

   pub fn exit_jsx_element<'a>(
       gen: &mut TransformGenerator<'a>,
       node: &mut JSXElement<'a>,
       ctx: &mut TraverseCtx<'a, ()>
   ) {
       // Move logic from TransformGenerator::exit_jsx_element here
   }
   ```

4. Similarly create helpers for:
   - enter_jsx_attribute / exit_jsx_attribute
   - enter_jsx_fragment / exit_jsx_fragment
   - enter_jsx_opening_element / exit_jsx_opening_element (if exists)

5. Update optimizer/src/transform/mod.rs:
   - Add `mod jsx;`
   - Optionally re-export public utilities if needed externally

Keep private helpers private to jsx.rs. Only expose the enter/exit functions.
  </action>
  <verify>
Run `cargo check -p optimizer` - should compile.
  </verify>
  <done>
- jsx.rs exists with JSX transformation logic
- Helper functions have correct signatures
- Module compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor generator.rs to use dispatcher pattern</name>
  <files>optimizer/src/transform/generator.rs</files>
  <action>
1. In generator.rs impl Traverse block, update JSX methods to delegate:
   ```rust
   fn enter_jsx_element(&mut self, node: &mut JSXElement<'a>, ctx: &mut TraverseCtx<'a, ()>) {
       jsx::enter_jsx_element(self, node, ctx);
   }

   fn exit_jsx_element(&mut self, node: &mut JSXElement<'a>, ctx: &mut TraverseCtx<'a, ()>) {
       jsx::exit_jsx_element(self, node, ctx);
   }
   ```

2. Remove the original implementation logic from generator.rs - it's now in jsx.rs

3. Add `use super::jsx;` at the top of generator.rs (or `use crate::transform::jsx;`)

4. The Traverse impl should now be much shorter - each JSX method is just one line

5. Verify no duplicate code exists between generator.rs and jsx.rs

IMPORTANT: The TransformGenerator struct must remain in generator.rs since jsx.rs functions take `&mut TransformGenerator` as parameter.
  </action>
  <verify>
Run `cargo test -p optimizer` - all 233 tests should pass.
Run `wc -l optimizer/src/transform/generator.rs` - should be noticeably smaller.
  </verify>
  <done>
- generator.rs Traverse impl uses dispatcher pattern for JSX
- jsx.rs contains all JSX logic
- All 233 tests pass
- generator.rs reduced in size
  </done>
</task>

</tasks>

<verification>
1. Module exists: `test -f optimizer/src/transform/jsx.rs`
2. Tests pass: `cargo test -p optimizer` shows 233 passed
3. Dispatcher pattern: `grep -c "jsx::" optimizer/src/transform/generator.rs` shows multiple calls
4. Line reduction: generator.rs is smaller than before extraction
</verification>

<success_criteria>
- jsx.rs module created with all JSX transformation logic
- generator.rs uses dispatcher pattern (one-line delegation)
- All 233 tests pass unchanged
- Clear separation of concerns between Traverse impl and JSX logic
</success_criteria>

<output>
After completion, create `.planning/phases/11-research-code-cleanup/11-03-SUMMARY.md`
</output>
