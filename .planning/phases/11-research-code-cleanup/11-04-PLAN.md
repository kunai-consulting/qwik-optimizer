---
phase: 11-research-code-cleanup
plan: 04
type: execute
wave: 4
depends_on: ["11-03"]
files_modified:
  - optimizer/src/transform/generator.rs
  - optimizer/src/transform/qrl.rs
  - optimizer/src/transform/scope.rs
  - optimizer/src/transform/mod.rs
autonomous: true

must_haves:
  truths:
    - "QRL-related logic is in a dedicated qrl.rs module"
    - "Scope tracking logic is in a dedicated scope.rs module"
    - "generator.rs uses dispatcher pattern for QRL and scope methods"
    - "All 233 tests still pass"
  artifacts:
    - path: "optimizer/src/transform/qrl.rs"
      provides: "QRL extraction and segment management"
      contains: "compute_scoped_idents"
    - path: "optimizer/src/transform/scope.rs"
      provides: "Declaration stack and scope tracking"
      contains: "decl_stack"
    - path: "optimizer/src/transform/generator.rs"
      provides: "Thin Traverse impl dispatcher"
      max_lines: 1500
  key_links:
    - from: "optimizer/src/transform/generator.rs"
      to: "optimizer/src/transform/qrl.rs"
      via: "qrl:: function calls"
      pattern: "qrl::"
    - from: "optimizer/src/transform/generator.rs"
      to: "optimizer/src/transform/scope.rs"
      via: "scope:: function calls"
      pattern: "scope::"
---

<objective>
Extract QRL and scope tracking logic from generator.rs to dedicated modules.

Purpose: Continue the dispatcher pattern established in 11-03. QRL extraction (~400 lines) and scope tracking (~200 lines) are distinct concerns that warrant their own modules. This brings generator.rs under 1500 lines.

Output: qrl.rs and scope.rs modules, generator.rs further reduced.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-research-code-cleanup/11-RESEARCH.md
@.planning/phases/11-research-code-cleanup/11-03-SUMMARY.md

# Source files
@optimizer/src/transform/generator.rs
@optimizer/src/transform/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create qrl.rs module</name>
  <files>optimizer/src/transform/qrl.rs, optimizer/src/transform/mod.rs</files>
  <action>
1. Create optimizer/src/transform/qrl.rs

2. Extract QRL-related logic from generator.rs:
   - `compute_scoped_idents()` function
   - Display name generation helpers
   - Hash computation helpers (if any beyond what's in component/)
   - Segment stack management helpers
   - Any QRL-specific utility functions

3. Create helper functions for call_expression handling (QRL extraction):
   ```rust
   pub fn enter_call_expression<'a>(
       gen: &mut TransformGenerator<'a>,
       node: &mut CallExpression<'a>,
       ctx: &mut TraverseCtx<'a, ()>
   ) {
       // QRL marker detection and extraction logic
   }

   pub fn exit_call_expression<'a>(
       gen: &mut TransformGenerator<'a>,
       node: &mut CallExpression<'a>,
       ctx: &mut TraverseCtx<'a, ()>
   ) {
       // QRL finalization logic
   }
   ```

4. Update optimizer/src/transform/mod.rs:
   - Add `mod qrl;`

Note: call_expression handling may have non-QRL logic too. Extract only QRL-specific parts, or create a helper that's called conditionally.
  </action>
  <verify>
Run `cargo check -p optimizer` - should compile.
  </verify>
  <done>
- qrl.rs exists with QRL extraction logic
- compute_scoped_idents is in qrl.rs
- Module compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scope.rs module</name>
  <files>optimizer/src/transform/scope.rs, optimizer/src/transform/mod.rs</files>
  <action>
1. Create optimizer/src/transform/scope.rs

2. Extract scope tracking logic from generator.rs:
   - decl_stack management helpers
   - IdPlusType enum/struct (if not already in component/)
   - Functions/closures for tracking declarations:
     - Variable declarations
     - Function parameters
     - Arrow function handling
     - Class declarations

3. Create helper functions:
   ```rust
   pub fn enter_variable_declarator<'a>(
       gen: &mut TransformGenerator<'a>,
       node: &VariableDeclarator<'a>,
       ctx: &mut TraverseCtx<'a, ()>
   ) {
       // decl_stack.push logic
   }

   pub fn exit_variable_declarator<'a>(
       gen: &mut TransformGenerator<'a>,
       node: &VariableDeclarator<'a>,
       ctx: &mut TraverseCtx<'a, ()>
   ) {
       // decl_stack.pop logic (if any)
   }
   ```

4. Similarly for:
   - enter/exit_function
   - enter/exit_arrow_function_expression
   - enter/exit_class
   - Any other scope-boundary methods

5. Update optimizer/src/transform/mod.rs:
   - Add `mod scope;`
  </action>
  <verify>
Run `cargo check -p optimizer` - should compile.
  </verify>
  <done>
- scope.rs exists with scope tracking logic
- decl_stack management is in scope.rs
- Module compiles
  </done>
</task>

<task type="auto">
  <name>Task 3: Update generator.rs dispatcher and verify</name>
  <files>optimizer/src/transform/generator.rs</files>
  <action>
1. Update generator.rs Traverse impl to use qrl:: and scope:: dispatchers:
   ```rust
   fn enter_call_expression(&mut self, node: &mut CallExpression<'a>, ctx: &mut TraverseCtx<'a, ()>) {
       qrl::enter_call_expression(self, node, ctx);
   }

   fn enter_variable_declarator(&mut self, node: &mut VariableDeclarator<'a>, ctx: &mut TraverseCtx<'a, ()>) {
       scope::enter_variable_declarator(self, node, ctx);
   }
   // etc.
   ```

2. Remove the implementation logic that's now in qrl.rs and scope.rs

3. Add imports: `use super::{qrl, scope};`

4. The Traverse impl should now be almost entirely one-line delegations

5. Run full test suite to verify correctness

CRITICAL: Some methods may need to call multiple dispatchers (e.g., exit_call_expression might do both QRL and scope work). Handle these carefully - either:
   - Call multiple dispatchers in sequence
   - Keep composite logic in generator.rs
  </action>
  <verify>
Run `cargo test -p optimizer --no-fail-fast` - all 233 tests should pass.
Run `wc -l optimizer/src/transform/generator.rs` - should be under 1500 lines.
  </verify>
  <done>
- generator.rs uses dispatcher pattern for qrl and scope
- All 233 tests pass
- generator.rs under 1500 lines
  </done>
</task>

</tasks>

<verification>
1. Modules exist: `ls optimizer/src/transform/` shows qrl.rs, scope.rs
2. Tests pass: `cargo test -p optimizer` shows 233 passed
3. Line count: `wc -l optimizer/src/transform/generator.rs` < 1500
4. Dispatcher calls: `grep -c "qrl::\|scope::" optimizer/src/transform/generator.rs` shows multiple
</verification>

<success_criteria>
- qrl.rs module with QRL extraction logic
- scope.rs module with scope tracking logic
- generator.rs under 1500 lines
- All 233 tests pass
- Clean separation of concerns
</success_criteria>

<output>
After completion, create `.planning/phases/11-research-code-cleanup/11-04-SUMMARY.md`
</output>
