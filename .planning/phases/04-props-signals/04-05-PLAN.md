---
phase: 04-props-signals
plan: 05
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - optimizer/src/transform.rs
  - optimizer/src/component/shared.rs
autonomous: true

must_haves:
  truths:
    - "bind:value={signal} transforms to value={signal} + on:input handler"
    - "bind:checked={signal} transforms to checked={signal} + on:input handler"
    - "Existing onInput$ handlers merge with bind handler as array"
    - "bind: directive itself is removed after transformation"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Bind directive transformation"
      contains: "bind:value"
    - path: "optimizer/src/component/shared.rs"
      provides: "Import constants for _val and _chk"
      contains: "_VAL"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "JSX attribute processing"
      via: "enter_jsx_attribute"
      pattern: "bind:"
---

<objective>
Implement bind:value and bind:checked directive transformation for two-way binding.

Purpose: Transform Qwik's bind directives into value/checked props plus on:input event handlers, enabling two-way data binding with signals.

Output: JSX attribute processing that detects bind:value and bind:checked, adds the value/checked prop with the signal, creates inlinedQrl with _val/_chk helper, and merges with any existing onInput$ handlers.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-props-signals/04-RESEARCH.md
@.planning/phases/04-props-signals/04-03-SUMMARY.md

Reference SWC implementation:
@qwik-core/src/optimizer/core/src/transform.rs (lines 1131-1253 for bind directive handling)

Reference snapshots:
- example_input_bind.snap - shows bind:value and bind:checked transformation
- should_merge_bind_value_and_on_input.snap - shows handler merging
- should_merge_on_input_and_bind_value.snap - order independence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _VAL and _CHK import constants</name>
  <files>optimizer/src/component/shared.rs</files>
  <action>
Add the bind directive helper constants to shared.rs:

```rust
/// Import for _val function (bind:value helper)
pub const _VAL: &str = "_val";

/// Import for _chk function (bind:checked helper)
pub const _CHK: &str = "_chk";

/// Prefix for bind directives
pub const BIND_PREFIX: &str = "bind:";
```

These helpers are called via inlinedQrl to update the signal when input changes.
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -10
Expect: Compiles without errors
  </verify>
  <done>
_VAL, _CHK, and BIND_PREFIX constants defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement bind directive detection and transformation</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add bind directive handling in JSX attribute processing:

1. **Add tracking for bind directives:**
```rust
/// Pending bind directives: (is_checked, signal_expr)
/// These are collected during attribute processing and applied at element exit
pending_bind_directives: Vec<(bool, Expression<'gen>)>,

/// Pending on:input handlers to merge with bind handlers
pending_on_input_handlers: Vec<Expression<'gen>>,
```

2. **Add bind directive detection:**
```rust
/// Check if attribute name is a bind directive
fn is_bind_directive(name: &str) -> Option<bool> {
    if name == "bind:value" {
        Some(false)  // is_checked = false
    } else if name == "bind:checked" {
        Some(true)   // is_checked = true
    } else {
        None
    }
}
```

3. **In enter_jsx_attribute, detect bind directives:**
```rust
// Get attribute name
let attr_name = self.get_jsx_attribute_name(node);

// Check for bind directive
if let Some(is_checked) = Self::is_bind_directive(&attr_name) {
    // Mark that we're processing a bind directive
    // Extract signal expression from value
    if let Some(JSXAttributeValue::ExpressionContainer(container)) = &node.value {
        if let Some(expr) = container.expression.as_expression() {
            self.pending_bind_directives.push((
                is_checked,
                expr.clone_in(ctx.ast.allocator)
            ));
            // Mark this attribute for removal (don't add to props)
        }
    }
}

// Check for existing onInput$ handler
if attr_name == "onInput$" || attr_name == "on:input" {
    // Store for later merging with bind handler
}
```

4. **Add method to create bind handler:**
```rust
/// Create inlinedQrl for bind handler
/// inlinedQrl(_val, "_val", [signal]) for bind:value
/// inlinedQrl(_chk, "_chk", [signal]) for bind:checked
fn create_bind_handler<'b>(
    &self,
    builder: &AstBuilder<'b>,
    is_checked: bool,
    signal_expr: Expression<'b>,
) -> Expression<'b> {
    let helper = if is_checked { "_chk" } else { "_val" };

    builder.expression_call(
        SPAN,
        builder.expression_identifier_reference(SPAN, "inlinedQrl"),
        NONE,
        builder.vec_from_array([
            Argument::from(builder.expression_identifier_reference(SPAN, helper)),
            Argument::from(builder.expression_string_literal(SPAN, helper)),
            Argument::from(builder.expression_array(
                SPAN,
                builder.vec1(ArrayExpressionElement::from(signal_expr)),
                None,
            )),
        ]),
        false,
    )
}
```

5. **Add method to merge handlers:**
```rust
/// Merge bind handler with existing onInput$ handlers
/// Returns array expression: [existingHandler, bindHandler]
fn merge_event_handlers<'b>(
    &self,
    builder: &AstBuilder<'b>,
    existing: Expression<'b>,
    bind_handler: Expression<'b>,
) -> Expression<'b> {
    // If existing is already an array, add to it
    // Otherwise, create new array with both
    match existing {
        Expression::ArrayExpression(arr) => {
            // Clone and add bind_handler
            let mut elements: Vec<ArrayExpressionElement<'b>> = arr.elements
                .iter()
                .map(|e| e.clone_in(builder.allocator))
                .collect();
            elements.push(ArrayExpressionElement::from(bind_handler));
            builder.expression_array(SPAN, builder.vec_from_iter(elements), None)
        }
        _ => {
            // Create new array
            builder.expression_array(
                SPAN,
                builder.vec_from_array([
                    ArrayExpressionElement::from(existing),
                    ArrayExpressionElement::from(bind_handler),
                ]),
                None,
            )
        }
    }
}
```

6. **In exit_jsx_element, apply bind transformations:**
After building props but before creating the element:

```rust
// Process pending bind directives
for (is_checked, signal_expr) in self.pending_bind_directives.drain(..) {
    let prop_name = if is_checked { "checked" } else { "value" };

    // Add value/checked prop with signal
    // Add to const_props
    const_props.push(/* value: signal or checked: signal */);

    // Create bind handler
    let bind_handler = self.create_bind_handler(ctx.ast, is_checked, signal_expr.clone());

    // Check for existing on:input handler
    let on_input_handler = if let Some(existing) = self.pending_on_input_handlers.pop() {
        self.merge_event_handlers(ctx.ast, existing, bind_handler)
    } else {
        bind_handler
    };

    // Add on:input prop
    const_props.push(/* "on:input": handler */);

    // Add imports
    let helper = if is_checked { "_chk" } else { "_val" };
    // Add import for helper and inlinedQrl
}
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -40
Expect: Compiles without errors
  </verify>
  <done>
TransformGenerator:
- Detects bind:value and bind:checked attributes
- Extracts signal expression from attribute value
- Creates inlinedQrl with _val/_chk helper
- Adds value/checked prop with signal
- Merges with existing onInput$ handlers
- Removes original bind: attribute
  </done>
</task>

<task type="auto">
  <name>Task 3: Add imports for bind directive helpers</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Ensure bind directive transformation adds required imports:

1. **Track import needs:**
```rust
needs_val_import: bool,
needs_chk_import: bool,
needs_inlined_qrl_import: bool,
```

2. **In exit_program, add imports:**
```rust
if self.needs_val_import {
    // import { _val } from "@qwik.dev/core"
}
if self.needs_chk_import {
    // import { _chk } from "@qwik.dev/core"
}
if self.needs_inlined_qrl_import {
    // import { inlinedQrl } from "@qwik.dev/core"
}
```

3. **Set flags when bind directive processed:**
```rust
// In bind directive processing
if is_checked {
    self.needs_chk_import = true;
} else {
    self.needs_val_import = true;
}
self.needs_inlined_qrl_import = true;
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -20
Expect: Compiles without errors
  </verify>
  <done>
Import tracking:
- needs_val_import set when bind:value used
- needs_chk_import set when bind:checked used
- needs_inlined_qrl_import set for both
- Imports added in exit_program
  </done>
</task>

<task type="auto">
  <name>Task 4: Add tests for bind directives</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add integration tests for bind directive transformation:

```rust
#[test]
fn test_bind_value_basic() {
    // Test: bind:value transforms to value + on:input
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const value = useSignal("");
            return <input bind:value={value} />;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should have value prop
    assert!(app.body.contains("\"value\":") || app.body.contains("value:"),
        "Expected value prop, got: {}", app.body);
    // Should have on:input handler with _val
    assert!(app.body.contains("on:input") && app.body.contains("_val"),
        "Expected on:input with _val, got: {}", app.body);
    // Should NOT have bind:value
    assert!(!app.body.contains("bind:value"),
        "bind:value should be removed, got: {}", app.body);
}

#[test]
fn test_bind_checked_basic() {
    // Test: bind:checked transforms to checked + on:input
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const checked = useSignal(false);
            return <input type="checkbox" bind:checked={checked} />;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should have checked prop
    assert!(app.body.contains("\"checked\":") || app.body.contains("checked:"),
        "Expected checked prop, got: {}", app.body);
    // Should have on:input handler with _chk
    assert!(app.body.contains("on:input") && app.body.contains("_chk"),
        "Expected on:input with _chk, got: {}", app.body);
}

#[test]
fn test_bind_value_merge_with_on_input() {
    // Test: existing onInput$ merges with bind:value handler
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const value = useSignal("");
            return (
                <input
                    onInput$={() => console.log("test")}
                    bind:value={value}
                />
            );
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should have array with both handlers
    // on:input: [originalHandler, inlinedQrl(_val, ...)]
    assert!(app.body.contains("[") && app.body.contains("_val"),
        "Expected merged handlers array, got: {}", app.body);
}

#[test]
fn test_bind_value_imports() {
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const value = useSignal("");
            return <input bind:value={value} />;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should import _val and inlinedQrl
    assert!(app.body.contains("import") && app.body.contains("_val"),
        "Expected _val import, got: {}", app.body);
    assert!(app.body.contains("inlinedQrl"),
        "Expected inlinedQrl import/usage, got: {}", app.body);
}

#[test]
fn test_bind_unknown_passes_through() {
    // Test: unknown bind directive passes through unchanged
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const stuff = useSignal();
            return <input bind:stuff={stuff} />;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should keep bind:stuff unchanged (not value or checked)
    assert!(app.body.contains("bind:stuff"),
        "Expected bind:stuff to pass through, got: {}", app.body);
}

#[test]
fn test_bind_order_independence() {
    // Test: order of onInput$ and bind:value doesn't matter
    let input1 = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const value = useSignal("");
            return <input bind:value={value} onInput$={() => log()} />;
        });
    "#;

    let input2 = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const value = useSignal("");
            return <input onInput$={() => log()} bind:value={value} />;
        });
    "#;

    let (app1, _) = do_transform(input1, &default_options(), None);
    let (app2, _) = do_transform(input2, &default_options(), None);

    // Both should merge handlers into array
    assert!(app1.body.contains("[") && app1.body.contains("_val"),
        "Expected merged handlers (order 1), got: {}", app1.body);
    assert!(app2.body.contains("[") && app2.body.contains("_val"),
        "Expected merged handlers (order 2), got: {}", app2.body);
}
```
  </action>
  <verify>
cargo test --package optimizer bind 2>&1
Expect: All bind directive tests pass
  </verify>
  <done>
Tests verify:
- bind:value -> value prop + on:input with _val
- bind:checked -> checked prop + on:input with _chk
- Handler merging when onInput$ exists
- _val/_chk/inlinedQrl imports added
- Unknown bind: passes through unchanged
- Order independence for handler merging
  </done>
</task>

</tasks>

<verification>
1. cargo build --package optimizer
2. cargo test --package optimizer
3. All 90+ tests pass
4. bind:value: `<input bind:value={sig}>` becomes `<input value={sig} on:input={inlinedQrl(_val, "_val", [sig])}>`
5. bind:checked: similar with checked prop and _chk helper
6. Merging: existing onInput$ + bind creates array `[handler, inlinedQrl...]`
7. Required imports added
</verification>

<success_criteria>
- _VAL, _CHK, BIND_PREFIX constants exported
- is_bind_directive detects bind:value and bind:checked
- create_bind_handler generates inlinedQrl call
- merge_event_handlers creates array when existing handler present
- value/checked prop added with signal
- on:input handler added with _val/_chk
- Original bind: attribute removed
- Imports added: _val, _chk, inlinedQrl
- Unknown bind: directives pass through
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-props-signals/04-05-SUMMARY.md`
</output>
