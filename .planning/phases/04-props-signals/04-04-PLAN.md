---
phase: 04-props-signals
plan: 04
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - optimizer/src/inlined_fn.rs
  - optimizer/src/lib.rs
  - optimizer/src/transform.rs
  - optimizer/src/component/shared.rs
autonomous: true

must_haves:
  truths:
    - "Computed expressions with props/signals generate _fnSignal calls"
    - "Hoisted functions created with positional params (p0, p1, ...)"
    - "String representation of expression included as third argument"
    - "Expressions over 150 chars do not get wrapped"
  artifacts:
    - path: "optimizer/src/inlined_fn.rs"
      provides: "_fnSignal generation module"
      contains: "convert_inlined_fn"
    - path: "optimizer/src/transform.rs"
      provides: "Hoisted function management"
      contains: "_hf"
  key_links:
    - from: "optimizer/src/inlined_fn.rs"
      to: "optimizer/src/transform.rs"
      via: "hoisted function creation"
      pattern: "_fnSignal"
---

<objective>
Implement _fnSignal generation for computed expressions involving signals and props.

Purpose: Enable reactive computed expressions in JSX by wrapping them in _fnSignal with hoisted arrow functions that take positional parameters.

Output: New inlined_fn.rs module that detects computed expressions (signal.property, props + local), creates hoisted functions, and generates _fnSignal calls with capture arrays and stringified expressions.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-props-signals/04-RESEARCH.md
@.planning/phases/04-props-signals/04-02-SUMMARY.md

Reference SWC implementation:
@qwik-core/src/optimizer/core/src/inlined_fn.rs (lines 24-115 for convert_inlined_fn)

Reference snapshots:
- example_props_wrapping.snap - shows _fnSignal with _hf0, _hf0_str
- example_derived_signals_div.snap - shows _fnSignal patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _FN_SIGNAL import constant and create module</name>
  <files>optimizer/src/component/shared.rs, optimizer/src/inlined_fn.rs, optimizer/src/lib.rs</files>
  <action>
1. Add to shared.rs:
```rust
/// Import for _fnSignal function (computed signal expressions)
pub const _FN_SIGNAL: &str = "_fnSignal";
```

2. Create optimizer/src/inlined_fn.rs:
```rust
//! Inlined function generation for _fnSignal
//!
//! This module handles the conversion of computed expressions involving
//! signals/stores/props into _fnSignal calls with hoisted arrow functions.

use crate::collector::Id;
use oxc_allocator::Allocator;
use oxc_ast::ast::*;
use oxc_ast::AstBuilder;
use oxc_codegen::{Codegen, CodegenOptions};
use oxc_span::SPAN;
use std::collections::HashMap;

/// Maximum expression length before skipping _fnSignal wrapping
const MAX_EXPR_LENGTH: usize = 150;

/// Result of converting an expression to _fnSignal
pub struct InlinedFnResult<'a> {
    /// The hoisted arrow function (e.g., (p0, p1) => p1 + p0.fromProps)
    pub hoisted_fn: Expression<'a>,
    /// Name for the hoisted function (e.g., "_hf0")
    pub hoisted_name: String,
    /// The string representation (e.g., "p1+p0.fromProps")
    pub hoisted_str: String,
    /// The capture array elements (identifiers to capture)
    pub captures: Vec<Expression<'a>>,
    /// Whether expression is const
    pub is_const: bool,
}

/// Check if expression should be wrapped in _fnSignal
pub fn should_wrap_in_fn_signal(
    expr: &Expression,
    scoped_idents: &[Id],
) -> bool {
    // Don't wrap arrow functions
    if matches!(expr, Expression::ArrowFunctionExpression(_)) {
        return false;
    }

    // Don't wrap if no scoped idents
    if scoped_idents.is_empty() {
        return false;
    }

    // Check if expression uses identifiers as object of member access
    is_used_as_object(expr, scoped_idents)
}

/// Check if any scoped identifier is used as object in member expression
fn is_used_as_object(expr: &Expression, scoped_idents: &[Id]) -> bool {
    match expr {
        Expression::MemberExpression(member) => {
            match member.as_ref() {
                MemberExpression::StaticMemberExpression(static_member) => {
                    // Check if object is one of our scoped idents
                    if let Expression::Identifier(ident) = &static_member.object {
                        if scoped_idents.iter().any(|id| id.0 == ident.name.as_str()) {
                            return true;
                        }
                    }
                    // Recursively check object
                    is_used_as_object(&static_member.object, scoped_idents)
                }
                MemberExpression::ComputedMemberExpression(computed) => {
                    is_used_as_object(&computed.object, scoped_idents)
                }
                _ => false,
            }
        }
        Expression::BinaryExpression(bin) => {
            is_used_as_object(&bin.left, scoped_idents) ||
            is_used_as_object(&bin.right, scoped_idents)
        }
        Expression::ConditionalExpression(cond) => {
            is_used_as_object(&cond.test, scoped_idents) ||
            is_used_as_object(&cond.consequent, scoped_idents) ||
            is_used_as_object(&cond.alternate, scoped_idents)
        }
        Expression::ObjectExpression(obj) => {
            obj.properties.iter().any(|prop| {
                if let ObjectPropertyKind::ObjectProperty(p) = prop {
                    is_used_as_object(&p.value, scoped_idents)
                } else {
                    false
                }
            })
        }
        Expression::ParenthesizedExpression(paren) => {
            is_used_as_object(&paren.expression, scoped_idents)
        }
        _ => false,
    }
}
```

3. Add to lib.rs:
```rust
pub mod inlined_fn;
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -20
Expect: Compiles without errors
  </verify>
  <done>
- _FN_SIGNAL constant added
- inlined_fn.rs module created with should_wrap_in_fn_signal
- is_used_as_object checks for member expression patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement convert_inlined_fn for hoisted function generation</name>
  <files>optimizer/src/inlined_fn.rs</files>
  <action>
Add the main conversion function to inlined_fn.rs:

```rust
/// Convert expression to _fnSignal call with hoisted function
pub fn convert_inlined_fn<'a>(
    expr: Expression<'a>,
    scoped_idents: Vec<Id>,
    hoisted_index: usize,
    builder: &AstBuilder<'a>,
    allocator: &'a Allocator,
) -> Option<InlinedFnResult<'a>> {
    // Don't wrap arrow functions
    if matches!(&expr, Expression::ArrowFunctionExpression(_)) {
        return None;
    }

    // Don't wrap if no scoped idents
    if scoped_idents.is_empty() {
        return None;
    }

    // Check if used as object (needs wrapping)
    if !is_used_as_object(&expr, &scoped_idents) {
        return None;
    }

    // Check if used in call expression (can't serialize)
    if contains_call_expression(&expr) {
        return None;
    }

    // Generate string representation
    let expr_str = render_expression(&expr);
    if expr_str.len() > MAX_EXPR_LENGTH {
        return None;
    }

    // Build parameter list: p0, p1, p2, ...
    let params: Vec<FormalParameter<'a>> = scoped_idents
        .iter()
        .enumerate()
        .map(|(i, _)| {
            builder.formal_parameter(
                SPAN,
                builder.vec(),  // decorators
                builder.binding_pattern(
                    builder.binding_pattern_kind_binding_identifier(
                        SPAN,
                        &format!("p{}", i)
                    ),
                    None,
                    false,
                ),
                None,
                false,
                false,
            )
        })
        .collect();

    // Build identifier map: old_id -> pN
    let mut ident_map: HashMap<String, String> = HashMap::new();
    for (i, id) in scoped_idents.iter().enumerate() {
        ident_map.insert(id.0.clone(), format!("p{}", i));
    }

    // Clone and transform expression with replaced identifiers
    let transformed_expr = replace_identifiers_in_expr(expr.clone_in(allocator), &ident_map, builder);

    // Build hoisted arrow function: (p0, p1) => transformed_expr
    let hoisted_fn = builder.expression_arrow_function(
        SPAN,
        false,  // expression
        false,  // async
        None,   // type params
        builder.formal_parameters(
            SPAN,
            FormalParameterKind::ArrowFormalParameters,
            builder.vec_from_iter(params),
            None,  // rest
        ),
        None,  // return type
        builder.function_body(
            SPAN,
            builder.vec(),  // directives
            builder.vec1(Statement::ExpressionStatement(
                builder.alloc(builder.expression_statement(SPAN, transformed_expr))
            )),
        ),
    );

    // Build captures array
    let captures: Vec<Expression<'a>> = scoped_idents
        .iter()
        .map(|id| builder.expression_identifier_reference(SPAN, &id.0))
        .collect();

    // Generate hoisted name and string
    let hoisted_name = format!("_hf{}", hoisted_index);
    let hoisted_str_name = format!("_hf{}_str", hoisted_index);

    // Transform string representation with replaced identifiers
    let transformed_str = replace_identifiers_in_str(&expr_str, &ident_map);

    Some(InlinedFnResult {
        hoisted_fn,
        hoisted_name,
        hoisted_str: transformed_str,
        captures,
        is_const: true,
    })
}

/// Check if expression contains a call expression (can't serialize)
fn contains_call_expression(expr: &Expression) -> bool {
    match expr {
        Expression::CallExpression(_) => true,
        Expression::BinaryExpression(bin) => {
            contains_call_expression(&bin.left) || contains_call_expression(&bin.right)
        }
        Expression::MemberExpression(member) => {
            match member.as_ref() {
                MemberExpression::StaticMemberExpression(m) => contains_call_expression(&m.object),
                MemberExpression::ComputedMemberExpression(m) => {
                    contains_call_expression(&m.object) || contains_call_expression(&m.expression)
                }
                _ => false,
            }
        }
        Expression::ObjectExpression(obj) => {
            obj.properties.iter().any(|prop| {
                if let ObjectPropertyKind::ObjectProperty(p) = prop {
                    contains_call_expression(&p.value)
                } else {
                    false
                }
            })
        }
        _ => false,
    }
}

/// Render expression to minified string
fn render_expression(expr: &Expression) -> String {
    let codegen_options = CodegenOptions {
        minify: true,
        ..Default::default()
    };
    // Use OXC codegen to render - simplified version
    // Full implementation would use proper codegen
    format!("{:?}", expr)  // Placeholder - needs proper implementation
}

/// Replace identifiers in expression string
fn replace_identifiers_in_str(expr_str: &str, ident_map: &HashMap<String, String>) -> String {
    let mut result = expr_str.to_string();
    for (old, new) in ident_map {
        result = result.replace(old, new);
    }
    result
}

/// Replace identifiers in expression AST
fn replace_identifiers_in_expr<'a>(
    expr: Expression<'a>,
    ident_map: &HashMap<String, String>,
    builder: &AstBuilder<'a>,
) -> Expression<'a> {
    // This is a simplified version - full implementation would use VisitMut
    expr
}
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -30
Expect: Compiles without errors
  </verify>
  <done>
convert_inlined_fn:
- Generates hoisted arrow function with positional params
- Builds identifier map for replacement
- Checks for call expressions (skip)
- Checks expression length (skip if > 150)
- Returns InlinedFnResult with hoisted_fn, name, str, captures
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate _fnSignal into JSX attribute processing</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add hoisted function management and _fnSignal call generation to TransformGenerator:

1. **Add hoisted function tracking:**
```rust
/// Hoisted functions for _fnSignal (name, function_expr, string_expr)
hoisted_fns: Vec<(String, Expression<'gen>, String)>,
/// Counter for hoisted function names
hoisted_fn_counter: usize,
/// Flag for needing _fnSignal import
needs_fn_signal_import: bool,
```

2. **Initialize in new():**
```rust
hoisted_fns: Vec::new(),
hoisted_fn_counter: 0,
needs_fn_signal_import: false,
```

3. **Add _fnSignal call creation method:**
```rust
/// Create _fnSignal call: _fnSignal(_hfN, [captures], _hfN_str)
fn create_fn_signal_call<'b>(
    &mut self,
    builder: &AstBuilder<'b>,
    hoisted_name: &str,
    captures: Vec<Expression<'b>>,
    str_name: &str,
) -> Expression<'b> {
    builder.expression_call(
        SPAN,
        builder.expression_identifier_reference(SPAN, "_fnSignal"),
        NONE,
        builder.vec_from_array([
            Argument::from(builder.expression_identifier_reference(SPAN, hoisted_name)),
            Argument::from(builder.expression_array(
                SPAN,
                builder.vec_from_iter(
                    captures.into_iter().map(ArrayExpressionElement::from)
                ),
                None,
            )),
            Argument::from(builder.expression_identifier_reference(SPAN, str_name)),
        ]),
        false,
    )
}
```

4. **In JSX attribute processing, check for _fnSignal wrapping:**
When processing var_props (not const_props), check if expression needs _fnSignal:

```rust
// After checking for _wrapProp, check for _fnSignal
use crate::inlined_fn::{should_wrap_in_fn_signal, convert_inlined_fn};

fn maybe_wrap_in_fn_signal<'b>(
    &mut self,
    expr: &mut Expression<'b>,
    scoped_idents: &[Id],
    builder: &AstBuilder<'b>,
    allocator: &'b Allocator,
) -> bool {
    if !should_wrap_in_fn_signal(expr, scoped_idents) {
        return false;
    }

    if let Some(result) = convert_inlined_fn(
        expr.clone_in(allocator),
        scoped_idents.to_vec(),
        self.hoisted_fn_counter,
        builder,
        allocator,
    ) {
        // Store hoisted function for later emission
        self.hoisted_fns.push((
            result.hoisted_name.clone(),
            result.hoisted_fn,
            result.hoisted_str.clone(),
        ));
        self.hoisted_fn_counter += 1;

        // Replace expression with _fnSignal call
        let str_name = format!("{}_str", result.hoisted_name);
        *expr = self.create_fn_signal_call(
            builder,
            &result.hoisted_name,
            result.captures,
            &str_name,
        );

        self.needs_fn_signal_import = true;
        return true;
    }
    false
}
```

5. **In exit_program, emit hoisted functions:**
Before the body codegen:
```rust
// Emit hoisted functions at top of module
for (name, fn_expr, str_val) in &self.hoisted_fns {
    // const _hf0 = (p0, p1) => expr;
    // const _hf0_str = "expr";
    // Insert as top-level statements
}
```

6. **Add imports:**
```rust
if self.needs_fn_signal_import {
    // Add _fnSignal import
}
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -30
Expect: Compiles without errors
  </verify>
  <done>
TransformGenerator:
- Tracks hoisted functions (name, expr, str)
- Increments hoisted_fn_counter for unique names
- create_fn_signal_call generates _fnSignal(fn, captures, str)
- maybe_wrap_in_fn_signal checks and wraps computed expressions
- Hoisted functions emitted at module top
- _fnSignal import added when used
  </done>
</task>

<task type="auto">
  <name>Task 4: Add tests for _fnSignal generation</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add integration tests for _fnSignal:

```rust
#[test]
fn test_fn_signal_computed_prop() {
    // Test: computed expression with prop
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ count }) => {
            return <div value={count + 1}>content</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should NOT use _fnSignal for simple addition without member access
    // Only member access patterns need _fnSignal
}

#[test]
fn test_fn_signal_member_access() {
    // Test: expression with member access on signal/store
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const store = useStore({ count: 0 });
            return <div value={store.count + 1}>content</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should use _fnSignal for member access
    assert!(app.body.contains("_fnSignal") || app.body.contains("_hf"),
        "Expected _fnSignal for computed expression, got: {}", app.body);
}

#[test]
fn test_fn_signal_hoisted_function() {
    // Test: hoisted function generated
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ data }) => {
            return <div computed={data.value ? 'yes' : 'no'}>content</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should have hoisted function like _hf0
    assert!(app.body.contains("_hf0") || app.body.contains("const _hf"),
        "Expected hoisted function, got: {}", app.body);
}

#[test]
fn test_fn_signal_no_call_expr() {
    // Test: expression with function call should NOT be wrapped
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const signal = useSignal(0);
            return <div value={signal.value + calculate()}>content</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should NOT use _fnSignal when expression contains function call
    // (Function calls can't be serialized)
}

#[test]
fn test_fn_signal_object_expression() {
    // Test: object expression with member access
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ fromProps }) => {
            const fromLocal = useSignal(0);
            return <div props={{ props: fromProps.value, local: fromLocal }}>content</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should use _fnSignal for object with member access
}
```
  </action>
  <verify>
cargo test --package optimizer fn_signal 2>&1
cargo test --package optimizer hoist 2>&1
Expect: All _fnSignal tests pass
  </verify>
  <done>
Tests verify:
- Member access expressions get _fnSignal wrapping
- Hoisted functions (_hf0, _hf0_str) generated
- Call expressions not wrapped (can't serialize)
- Object expressions with member access wrapped
- _fnSignal import added when used
  </done>
</task>

</tasks>

<verification>
1. cargo build --package optimizer
2. cargo test --package optimizer
3. All 85+ tests pass
4. Computed expressions: `store.count + 1` becomes `_fnSignal(_hf0, [store], _hf0_str)`
5. Hoisted function: `const _hf0 = (p0) => p0.count + 1`
6. String literal: `const _hf0_str = "p0.count+1"`
</verification>

<success_criteria>
- _FN_SIGNAL constant exported from component module
- inlined_fn.rs module creates hoisted functions with positional params
- should_wrap_in_fn_signal detects member access patterns
- convert_inlined_fn returns hoisted function, name, string, captures
- Call expressions skip wrapping
- Expressions > 150 chars skip wrapping
- Hoisted functions emitted at module top
- _fnSignal import added when used
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-props-signals/04-04-SUMMARY.md`
</output>
