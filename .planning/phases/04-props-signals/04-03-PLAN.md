---
phase: 04-props-signals
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - optimizer/src/transform.rs
  - optimizer/src/component/shared.rs
autonomous: true

must_haves:
  truths:
    - "Direct prop access in JSX becomes _wrapProp(_rawProps, 'propName')"
    - "Signal .value access generates _wrapProp(signal)"
    - "Non-prop identifiers (locals, imports) are not wrapped"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "_wrapProp generation in JSX"
      contains: "_wrapProp"
    - path: "optimizer/src/component/shared.rs"
      provides: "Import constant for _wrapProp"
      contains: "_WRAP_PROP"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "JSX attribute processing"
      via: "exit_jsx_attribute"
      pattern: "_wrapProp"
---

<objective>
Implement _wrapProp generation for prop access in JSX attributes and signal .value access.

Purpose: Wrap prop accesses with _wrapProp to enable runtime reactivity when props change. This is essential for Qwik's fine-grained reactivity system.

Output: Extended JSX attribute processing that detects prop identifiers and wraps them with _wrapProp(_rawProps, "propName"), and signal.value access wrapped with _wrapProp(signal).
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-props-signals/04-RESEARCH.md
@.planning/phases/04-props-signals/04-01-SUMMARY.md
@.planning/phases/04-props-signals/04-02-SUMMARY.md

Reference snapshots:
- example_props_wrapping.snap - shows _wrapProp(_rawProps, "fromProps")
- example_derived_signals_div.snap - shows _wrapProp(signal) for .value access
- should_destructure_args.snap - shows _wrapProp usage with _rawProps
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _WRAP_PROP import constant</name>
  <files>optimizer/src/component/shared.rs</files>
  <action>
Add the _wrapProp import constant to shared.rs:

```rust
/// Import for _wrapProp function (prop wrapping for reactivity)
pub const _WRAP_PROP: &str = "_wrapProp";
```

Export from component module for use in transform.rs.
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -10
Expect: Compiles without errors
  </verify>
  <done>
_WRAP_PROP constant defined and exportable
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement _wrapProp generation for prop access</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add _wrapProp generation in JSX attribute value processing:

1. **Add helper method to TransformGenerator:**
```rust
/// Create _wrapProp call for prop access
/// _wrapProp(_rawProps, "propName")
fn create_wrap_prop_call<'b>(
    &self,
    builder: &AstBuilder<'b>,
    raw_props_name: &str,
    prop_key: &str,
) -> Expression<'b> {
    builder.expression_call(
        SPAN,
        builder.expression_identifier_reference(SPAN, "_wrapProp"),
        NONE,
        builder.vec_from_array([
            Argument::from(builder.expression_identifier_reference(SPAN, raw_props_name)),
            Argument::from(builder.expression_string_literal(SPAN, prop_key)),
        ]),
        false,
    )
}

/// Create _wrapProp call for signal.value access
/// _wrapProp(signal)
fn create_wrap_prop_signal<'b>(
    &self,
    builder: &AstBuilder<'b>,
    signal_expr: Expression<'b>,
) -> Expression<'b> {
    builder.expression_call(
        SPAN,
        builder.expression_identifier_reference(SPAN, "_wrapProp"),
        NONE,
        builder.vec1(Argument::from(signal_expr)),
        false,
    )
}
```

2. **Track need for _wrapProp import:**
Add flag:
```rust
needs_wrap_prop_import: bool,
```

3. **In exit_jsx_attribute_value, check for prop access:**
When processing JSX attribute values (in exit_jsx_attribute or exit_jsx_expression_container):

```rust
// Check if this identifier is a prop that needs wrapping
fn should_wrap_prop(&self, expr: &Expression) -> Option<(String, String)> {
    // Check for direct identifier that's in props_identifiers
    if let Expression::Identifier(ident) = expr {
        let id = (ident.name.to_string(), /* scope id */);
        if let Some(prop_key) = self.props_identifiers.get(&id) {
            return Some(("_rawProps".to_string(), prop_key.clone()));
        }
    }
    None
}

// Check if this is signal.value access
fn should_wrap_signal_value(&self, expr: &Expression) -> bool {
    if let Expression::MemberExpression(member) = expr {
        if let MemberExpression::StaticMemberExpression(static_member) = member.as_ref() {
            if static_member.property.name == "value" {
                // Check if object is a signal (heuristic: useSignal/useStore result)
                // For now, any .value access in var_props context
                return true;
            }
        }
    }
    false
}
```

4. **Apply wrapping in exit_jsx_attribute:**
Modify the JSX attribute processing to wrap prop identifiers:

```rust
// In exit_jsx_attribute, when building const_props/var_props:
fn process_jsx_attr_value<'b>(
    &mut self,
    value: &mut Expression<'b>,
    builder: &AstBuilder<'b>,
) {
    // Check for prop that needs _wrapProp
    if let Some((raw_props, prop_key)) = self.should_wrap_prop(value) {
        let wrapped = self.create_wrap_prop_call(builder, &raw_props, &prop_key);
        *value = wrapped;
        self.needs_wrap_prop_import = true;
    }
    // Check for signal.value that needs _wrapProp
    else if self.should_wrap_signal_value(value) {
        if let Expression::MemberExpression(member) = value {
            if let MemberExpression::StaticMemberExpression(static_member) = member.as_ref() {
                // Get the signal expression (member.object)
                let signal_expr = static_member.object.clone_in(builder.allocator);
                let wrapped = self.create_wrap_prop_signal(builder, signal_expr);
                *value = wrapped;
                self.needs_wrap_prop_import = true;
            }
        }
    }
}
```

5. **Add _wrapProp import in exit_program:**
```rust
if self.needs_wrap_prop_import {
    // Add import for _wrapProp
    // Use existing import infrastructure
}
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -30
Expect: Compiles without errors
  </verify>
  <done>
TransformGenerator:
- create_wrap_prop_call generates _wrapProp(_rawProps, "key")
- create_wrap_prop_signal generates _wrapProp(signal)
- should_wrap_prop detects prop identifiers from props_identifiers map
- should_wrap_signal_value detects .value member access
- _wrapProp import added when used
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for _wrapProp generation</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add integration tests for _wrapProp:

```rust
#[test]
fn test_wrap_prop_basic() {
    // Test: direct prop access in JSX
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ message }) => {
            return <div>{message}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("_wrapProp(_rawProps"),
        "Expected _wrapProp for prop access, got: {}", app.body);
}

#[test]
fn test_wrap_prop_attribute() {
    // Test: prop as JSX attribute value
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ id }) => {
            return <div id={id}>content</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("_wrapProp(_rawProps, \"id\")"),
        "Expected _wrapProp for id prop, got: {}", app.body);
}

#[test]
fn test_wrap_prop_signal_value() {
    // Test: signal.value access generates _wrapProp
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const count = useSignal(0);
            return <div>{count.value}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Note: Direct signal passes through, .value gets wrapped
    assert!(app.body.contains("_wrapProp(count)") ||
            app.body.contains("_wrapProp( count)"),
        "Expected _wrapProp for signal.value, got: {}", app.body);
}

#[test]
fn test_wrap_prop_import() {
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ value }) => {
            return <div>{value}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("import") && app.body.contains("_wrapProp"),
        "Expected _wrapProp import, got: {}", app.body);
}

#[test]
fn test_no_wrap_local_vars() {
    // Test: local variables (not props) should not be wrapped
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(() => {
            const local = "hello";
            return <div>{local}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    // Should NOT wrap local constant
    assert!(!app.body.contains("_wrapProp"),
        "Should not wrap local vars, got: {}", app.body);
}
```
  </action>
  <verify>
cargo test --package optimizer wrap 2>&1
Expect: All _wrapProp tests pass
  </verify>
  <done>
Tests verify:
- Direct prop access wrapped: {{ message }} -> _wrapProp(_rawProps, "message")
- Prop as attribute value wrapped
- signal.value access wrapped with _wrapProp(signal)
- _wrapProp import added when used
- Local variables NOT wrapped
  </done>
</task>

</tasks>

<verification>
1. cargo build --package optimizer
2. cargo test --package optimizer
3. All 80+ tests pass (existing + new wrap tests)
4. Prop access: `{message}` becomes `_wrapProp(_rawProps, "message")`
5. Signal.value: `{count.value}` becomes `_wrapProp(count)`
6. Import added when _wrapProp used
</verification>

<success_criteria>
- _WRAP_PROP constant exported from component module
- create_wrap_prop_call generates correct _wrapProp(_rawProps, "key") syntax
- create_wrap_prop_signal generates _wrapProp(signal) for .value access
- Prop identifiers detected via props_identifiers map
- Signal.value access detected and wrapped
- _wrapProp import added when used
- Local variables and imports NOT wrapped
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-props-signals/04-03-SUMMARY.md`
</output>
