---
phase: 04-props-signals
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - optimizer/src/props_destructuring.rs
  - optimizer/src/transform.rs
  - optimizer/src/component/shared.rs
autonomous: true

must_haves:
  truths:
    - "Rest pattern (...rest) generates _restProps(_rawProps, [omit_list])"
    - "Aliased props ({ count: c }) track both local name and property key"
    - "Default values ({ count = 0 }) generate nullish coalescing expressions"
  artifacts:
    - path: "optimizer/src/props_destructuring.rs"
      provides: "Rest props and defaults handling"
      contains: "_restProps"
    - path: "optimizer/src/component/shared.rs"
      provides: "Import constants for _restProps"
      contains: "_REST_PROPS"
  key_links:
    - from: "optimizer/src/props_destructuring.rs"
      to: "optimizer/src/transform.rs"
      via: "rest statement injection"
      pattern: "_restProps"
---

<objective>
Implement rest props (_restProps) generation, prop aliasing, and default value handling.

Purpose: Complete the props destructuring transformation to handle all ObjectPattern variants including rest patterns and default values.

Output: Extended props_destructuring.rs that generates _restProps calls for rest patterns, tracks aliased props correctly, and generates nullish coalescing for default values.
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-props-signals/04-RESEARCH.md
@.planning/phases/04-props-signals/04-01-SUMMARY.md

Reference SWC implementation:
@qwik-core/src/optimizer/core/src/props_destructuring.rs (lines 312-430 for transform_pat, 432-520 for rest handling)

Reference snapshot:
- should_destructure_args.snap - shows _restProps with omit array
- should_convert_rest_props.snap - shows rest-only destructuring
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _REST_PROPS import constant</name>
  <files>optimizer/src/component/shared.rs</files>
  <action>
Add the _restProps import constant to shared.rs, following existing patterns:

```rust
/// Import for _restProps function (rest props destructuring)
pub const _REST_PROPS: &str = "_restProps";
```

Ensure it's exported from the component module so it can be used in transform.rs for import generation.
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -20
Expect: Compiles without errors
  </verify>
  <done>
_REST_PROPS constant defined and accessible from transform.rs
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rest props extraction and statement generation</name>
  <files>optimizer/src/props_destructuring.rs</files>
  <action>
Extend PropsDestructuring to handle rest patterns:

1. **Add rest tracking to struct:**
```rust
pub struct PropsDestructuring<'a> {
    // ... existing fields ...
    /// Rest identifier if pattern has ...rest
    pub rest_id: Option<Id>,
    /// List of prop keys to omit from rest (all explicit props)
    pub omit_keys: Vec<String>,
}
```

2. **Update transform_component_props to detect rest:**
```rust
// In the ObjectPattern iteration:
for prop in &obj_pat.properties {
    match prop {
        BindingProperty::Property(kv) => {
            // ... existing property handling ...
            // Add key to omit list
            if let Some(key) = prop_key.clone() {
                self.omit_keys.push(key);
            }
        }
    }
}

// Check for rest element
if let Some(rest) = &obj_pat.rest {
    if let BindingPatternKind::BindingIdentifier(ident) = &rest.argument.kind {
        self.rest_id = Some((
            ident.name.to_string(),
            ident.symbol_id.get().unwrap_or_default()
        ));
    }
}
```

3. **Add method to generate _restProps statement:**
```rust
/// Generate: const rest = _restProps(_rawProps, ["prop1", "prop2", ...])
pub fn generate_rest_stmt<'b>(
    &self,
    builder: &AstBuilder<'b>,
) -> Option<Statement<'b>> {
    let rest_id = self.rest_id.as_ref()?;

    // Build omit array: ["prop1", "prop2", ...]
    let omit_elements: Vec<ArrayExpressionElement> = self.omit_keys
        .iter()
        .map(|key| {
            ArrayExpressionElement::from(
                builder.expression_string_literal(SPAN, key.as_str())
            )
        })
        .collect();

    let omit_array = builder.expression_array(
        SPAN,
        builder.vec_from_iter(omit_elements),
        None,
    );

    // Build: _restProps(_rawProps, omitArray)
    // If omit is empty: _restProps(_rawProps)
    let args = if self.omit_keys.is_empty() {
        builder.vec1(Argument::from(
            builder.expression_identifier_reference(SPAN, self.raw_props_name)
        ))
    } else {
        builder.vec_from_array([
            Argument::from(builder.expression_identifier_reference(SPAN, self.raw_props_name)),
            Argument::from(omit_array),
        ])
    };

    let call_expr = builder.expression_call(
        SPAN,
        builder.expression_identifier_reference(SPAN, "_restProps"),
        NONE,
        args,
        false,
    );

    // Build: const rest = _restProps(...)
    let decl = builder.variable_declaration(
        SPAN,
        VariableDeclarationKind::Const,
        builder.vec1(builder.variable_declarator(
            SPAN,
            VariableDeclarationKind::Const,
            builder.binding_pattern(
                builder.binding_pattern_kind_binding_identifier(SPAN, &rest_id.0),
                None,
                false,
            ),
            Some(call_expr),
            false,
        )),
        false,
    );

    Some(Statement::VariableDeclaration(builder.alloc(decl)))
}
```

4. **Handle defaults with nullish coalescing:**
Track default values during pattern extraction:
```rust
/// Map from local identifier to (prop_key, Option<default_expr>)
pub identifiers_with_defaults: HashMap<Id, (String, Option<Expression<'a>>)>,
```

For `{ count = 0 }`:
```rust
// When default is present, store it
if let Some(default_expr) = &assign_pat.right {
    self.identifiers_with_defaults.insert(
        local_id,
        (prop_key, Some(default_expr.clone_in(self.allocator)))
    );
}
```
  </action>
  <verify>
cargo build --package optimizer 2>&1 | head -30
cargo test --package optimizer props 2>&1
Expect: Compiles and existing props tests pass
  </verify>
  <done>
PropsDestructuring handles:
- Rest pattern extraction (rest_id populated)
- Omit keys collection (all explicit prop names)
- generate_rest_stmt creates _restProps call
- Default value tracking for nullish coalescing
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate rest statement injection into transform</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Update TransformGenerator to inject _restProps statement and add import:

1. **Store rest info from props transformation:**
```rust
/// Rest props info: (rest_id_name, omit_keys)
props_rest_info: Option<(String, Vec<String>)>,
```

2. **In exit_call_expression, after props transform:**
```rust
if props_trans.transform_component_props(arrow, &ctx.ast) {
    self.props_identifiers = props_trans.identifiers;

    // Store rest info if present
    if let Some(rest_id) = &props_trans.rest_id {
        self.props_rest_info = Some((
            rest_id.0.clone(),
            props_trans.omit_keys.clone()
        ));

        // Inject _restProps statement at start of function body
        if let Some(rest_stmt) = props_trans.generate_rest_stmt(&ctx.ast) {
            if let FunctionBody::BlockStatement(block) = &mut arrow.body {
                block.statements.insert(0, rest_stmt);
            }
        }

        // Add _restProps import
        if let Some(imports) = self.import_stack.last_mut() {
            imports.insert(Import {
                path: "@qwik.dev/core".into(),
                names: vec![ImportId::Named("_restProps".into())].into_iter().collect(),
            });
        }
    }
}
```

3. **Clear state after component:**
```rust
self.props_rest_info = None;
```
  </action>
  <verify>
cargo test --package optimizer 2>&1 | tail -20
Expect: All tests pass
  </verify>
  <done>
TransformGenerator:
- Stores rest info from props transformation
- Injects _restProps statement at function body start
- Adds _restProps import when rest pattern present
- State cleared after component processing
  </done>
</task>

<task type="auto">
  <name>Task 4: Add tests for rest props and aliasing</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add integration tests in transform.rs test module:

```rust
#[test]
fn test_props_rest_pattern() {
    // Test: component$(({ message, ...rest }) => ...)
    // Should output: const rest = _restProps(_rawProps, ["message"])
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ message, ...rest }) => {
            return <span {...rest}>{message}</span>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("_restProps"),
        "Expected _restProps call, got: {}", app.body);
    assert!(app.body.contains("_rawProps"),
        "Expected _rawProps parameter, got: {}", app.body);
}

#[test]
fn test_props_rest_only() {
    // Test: component$(({ ...props }) => ...)
    // Should output: const props = _restProps(_rawProps)
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ ...props }) => {
            return <div>{props.value}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("_restProps(_rawProps)") ||
            app.body.contains("_restProps( _rawProps)"),
        "Expected _restProps with no omit array, got: {}", app.body);
}

#[test]
fn test_props_aliasing() {
    // Test: component$(({ count: c }) => ...)
    // Should track: c -> "count"
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ count: c, name: n }) => {
            return <div>{c} {n}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("_rawProps"),
        "Expected _rawProps, got: {}", app.body);
    // Note: Full aliasing replacement will be in later plan with _wrapProp
}

#[test]
fn test_props_import_added() {
    let input = r#"
        import { component$ } from "@qwik.dev/core";
        export const Cmp = component$(({ message, ...rest }) => {
            return <div {...rest}>{message}</div>;
        });
    "#;

    let (app, errors) = do_transform(input, &default_options(), None);
    assert!(errors.is_empty());
    assert!(app.body.contains("_restProps") &&
            app.body.contains("@qwik.dev/core"),
        "Expected _restProps import from @qwik.dev/core");
}
```
  </action>
  <verify>
cargo test --package optimizer props 2>&1
cargo test --package optimizer rest 2>&1
Expect: All new tests pass
  </verify>
  <done>
Tests verify:
- Rest pattern generates _restProps with omit array
- Rest-only pattern generates _restProps with no omit
- Aliased props track correctly (c -> "count")
- _restProps import added when rest pattern present
  </done>
</task>

</tasks>

<verification>
1. cargo build --package optimizer
2. cargo test --package optimizer
3. All 77+ tests pass
4. Rest props: `({ message, ...rest })` generates `const rest = _restProps(_rawProps, ["message"])`
5. Rest only: `({ ...props })` generates `const props = _restProps(_rawProps)`
6. Aliased props tracked with correct property keys
</verification>

<success_criteria>
- _REST_PROPS constant exported from component module
- PropsDestructuring extracts rest pattern and generates _restProps call
- Omit array includes all explicit prop names
- Rest-only pattern works (empty omit array)
- Aliased props correctly map local name to property key
- _restProps import added when needed
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-props-signals/04-02-SUMMARY.md`
</output>
