---
phase: 07-entry-strategies
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - optimizer/src/entry_strategy.rs
autonomous: true

must_haves:
  truths:
    - "PerComponentStrategy groups segments by root component"
    - "SmartStrategy separates event handlers without captures"
    - "Both strategies produce output matching SWC exactly"
    - "InlineStrategy, SingleStrategy, PerSegmentStrategy verified via tests"
  artifacts:
    - path: "optimizer/src/entry_strategy.rs"
      provides: "Working PerComponentStrategy and SmartStrategy implementations"
      contains: "context.first().map_or_else"
  key_links:
    - from: "optimizer/src/entry_strategy.rs"
      to: "optimizer/src/component/segment_data.rs"
      via: "Accesses scoped_idents, ctx_kind, ctx_name, origin"
      pattern: "segment\\.(scoped_idents|ctx_kind|ctx_name|origin)"
---

<objective>
Implement PerComponentStrategy and SmartStrategy following SWC reference exactly.

Purpose: These strategies control how QRL segments are grouped for bundling.
- PerComponentStrategy: Groups all segments by their root component
- SmartStrategy: Optimizes by separating event handlers without captures

Note: InlineStrategy (ENT-01), SingleStrategy (ENT-02), and PerSegmentStrategy (ENT-03)
are ALREADY implemented in entry_strategy.rs. Task 3 verifies these pre-existing implementations.

Output: Working implementations that match SWC output exactly
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-entry-strategies/07-RESEARCH.md
@.planning/phases/07-entry-strategies/07-01-SUMMARY.md

# Implementation files
@optimizer/src/entry_strategy.rs
@optimizer/src/component/segment_data.rs

# SWC reference (exact code to port)
@qwik-core/src/optimizer/core/src/entry_strategy.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PerComponentStrategy</name>
  <files>optimizer/src/entry_strategy.rs</files>
  <action>
Replace the panic! in PerComponentStrategy::get_entry_for_sym with the actual implementation.

Port from SWC (qwik-core/src/optimizer/core/src/entry_strategy.rs lines 76-82):

```rust
impl EntryPolicy for PerComponentStrategy {
    fn get_entry_for_sym(&self, context: &[String], segment: &SegmentData) -> Option<String> {
        context.first().map_or_else(
            || Some(ENTRY_SEGMENTS.to_string()),
            |root| Some([segment.origin.display().to_string().as_str(), "_entry_", root].concat()),
        )
    }
}
```

Key differences from SWC:
- SWC uses `Atom` for strings, OXC uses `String`
- SWC's `segment.origin` is a string/Atom, OXC's is `PathBuf` - use `.display().to_string()`
- ENTRY_SEGMENTS is already defined as `const ENTRY_SEGMENTS: &str = "entry_segments";`

Logic explanation:
- If context is empty (top-level QRL), return "entry_segments" to group all together
- Otherwise, return "{origin}_entry_{root}" where root is the first context item (component name)
- This groups all QRLs from the same component into one file
  </action>
  <verify>cargo build --package qwik-optimizer 2>&1 | head -30</verify>
  <done>PerComponentStrategy returns "{origin}_entry_{root}" for component QRLs or "entry_segments" for top-level</done>
</task>

<task type="auto">
  <name>Task 2: Implement SmartStrategy</name>
  <files>optimizer/src/entry_strategy.rs</files>
  <action>
Replace the panic! in SmartStrategy::get_entry_for_sym with the actual implementation.

Port from SWC (qwik-core/src/optimizer/core/src/entry_strategy.rs lines 94-112):

```rust
impl EntryPolicy for SmartStrategy {
    fn get_entry_for_sym(&self, context: &[String], segment: &SegmentData) -> Option<String> {
        // Event handlers without scope variables are put into a separate file
        if segment.scoped_idents.is_empty()
            && (segment.ctx_kind != SegmentKind::Function || segment.ctx_name == "event$")
        {
            return None;
        }

        // Everything else is put into a single file per component
        // This means that all QRLs for a component are loaded together
        // if one is used
        context.first().map_or_else(
            // Top-level QRLs are put into a separate file
            || None,
            // Other QRLs are put into a file named after the original file + the root component
            |root| Some([segment.origin.display().to_string().as_str(), "_entry_", root].concat()),
        )
    }
}
```

Add import at top if not already present:
```rust
use crate::component::SegmentKind;
```

Logic explanation:
1. First check: Event handlers (not Function kind OR named "event$") with empty scoped_idents
   go to separate files (return None) - they don't need to load with component
2. Second check: If context is empty (top-level QRL), return None for separate file
3. Otherwise: Group by component like PerComponentStrategy

The key insight: Smart strategy optimizes by NOT grouping simple event handlers
that don't capture any state - they can be loaded independently.
  </action>
  <verify>cargo build --package qwik-optimizer 2>&1 | head -30</verify>
  <done>SmartStrategy separates stateless event handlers, groups others by component</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for all entry strategies (including pre-existing ENT-01/02/03)</name>
  <files>optimizer/src/entry_strategy.rs</files>
  <action>
Add a `#[cfg(test)]` module at the bottom of entry_strategy.rs with comprehensive tests.

IMPORTANT: This task tests ALL strategies including the pre-existing InlineStrategy (ENT-01),
SingleStrategy (ENT-02), and PerSegmentStrategy (ENT-03) which are already implemented.

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::component::{SegmentData, SegmentKind};
    use std::path::PathBuf;

    fn make_segment(ctx_name: &str, origin: &str, scoped_idents: Vec<(&str, u32)>) -> SegmentData {
        use oxc_semantic::ScopeId;
        let scoped: Vec<_> = scoped_idents
            .into_iter()
            .map(|(name, id)| (name.to_string(), ScopeId::new(id as usize)))
            .collect();
        SegmentData::new(
            ctx_name,
            "test_display".to_string(),
            "hash123".to_string(),
            PathBuf::from(origin),
            scoped,
            vec![],
            None,
        )
    }

    // =========================================
    // InlineStrategy tests (ENT-01 - PRE-EXISTING)
    // =========================================
    #[test]
    fn test_inline_strategy_always_returns_entry_segments() {
        let strategy = InlineStrategy;
        let segment = make_segment("component$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            Some("entry_segments".to_string())
        );
    }

    #[test]
    fn test_inline_strategy_no_context() {
        let strategy = InlineStrategy;
        let segment = make_segment("$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&[], &segment),
            Some("entry_segments".to_string())
        );
    }

    // =========================================
    // SingleStrategy tests (ENT-02 - PRE-EXISTING)
    // =========================================
    #[test]
    fn test_single_strategy_always_returns_entry_segments() {
        let strategy = SingleStrategy::new();
        let segment = make_segment("component$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            Some("entry_segments".to_string())
        );
    }

    // =========================================
    // PerSegmentStrategy tests (ENT-03 - PRE-EXISTING)
    // =========================================
    #[test]
    fn test_per_segment_strategy_always_returns_none() {
        let strategy = PerSegmentStrategy::new();
        let segment = make_segment("onClick$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            None
        );
    }

    #[test]
    fn test_per_segment_strategy_no_context() {
        let strategy = PerSegmentStrategy::new();
        let segment = make_segment("$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&[], &segment),
            None
        );
    }

    // =========================================
    // PerComponentStrategy tests (ENT-04)
    // =========================================
    #[test]
    fn test_per_component_with_context() {
        let strategy = PerComponentStrategy::new();
        let segment = make_segment("onClick$", "src/Counter.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            Some("src/Counter.tsx_entry_Counter".to_string())
        );
    }

    #[test]
    fn test_per_component_no_context() {
        let strategy = PerComponentStrategy::new();
        let segment = make_segment("$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&[], &segment),
            Some("entry_segments".to_string())
        );
    }

    // =========================================
    // SmartStrategy tests (ENT-05)
    // =========================================
    #[test]
    fn test_smart_event_handler_no_captures() {
        let strategy = SmartStrategy::new();
        // Event handler without captures -> separate file
        let segment = make_segment("onClick$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            None
        );
    }

    #[test]
    fn test_smart_event_handler_with_captures() {
        let strategy = SmartStrategy::new();
        // Event handler WITH captures -> grouped with component
        let segment = make_segment("onClick$", "src/Counter.tsx", vec![("count", 1)]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            Some("src/Counter.tsx_entry_Counter".to_string())
        );
    }

    #[test]
    fn test_smart_function_with_context() {
        let strategy = SmartStrategy::new();
        // Function type (not event handler) -> grouped with component
        let segment = make_segment("component$", "src/Counter.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&["Counter".into()], &segment),
            Some("src/Counter.tsx_entry_Counter".to_string())
        );
    }

    #[test]
    fn test_smart_no_context() {
        let strategy = SmartStrategy::new();
        // No context -> separate file
        let segment = make_segment("component$", "test.tsx", vec![]);
        assert_eq!(
            strategy.get_entry_for_sym(&[], &segment),
            None
        );
    }
}
```
  </action>
  <verify>cargo test --package qwik-optimizer entry_strategy 2>&1 | tail -40</verify>
  <done>All entry strategy tests pass, verifying correct behavior for InlineStrategy (ENT-01), SingleStrategy (ENT-02), PerSegmentStrategy (ENT-03), PerComponentStrategy (ENT-04), and SmartStrategy (ENT-05)</done>
</task>

</tasks>

<verification>
1. `cargo build --package qwik-optimizer` compiles without errors
2. `cargo test --package qwik-optimizer entry_strategy` - all strategy tests pass
3. `cargo test --package qwik-optimizer` - all 148+ existing tests pass
4. PerComponentStrategy returns "{origin}_entry_{root}" with context, "entry_segments" without
5. SmartStrategy returns None for stateless event handlers, groups others by component
6. Pre-existing strategies (InlineStrategy, SingleStrategy, PerSegmentStrategy) verified working
</verification>

<success_criteria>
- PerComponentStrategy implemented matching SWC exactly (ENT-04)
- SmartStrategy implemented matching SWC exactly (ENT-05)
- No panics in any strategy implementation
- 10+ unit tests pass covering all strategy behaviors
- InlineStrategy (ENT-01), SingleStrategy (ENT-02), PerSegmentStrategy (ENT-03) verified via tests
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-entry-strategies/07-02-SUMMARY.md`
</output>
