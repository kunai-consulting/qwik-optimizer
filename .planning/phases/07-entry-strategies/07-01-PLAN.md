---
phase: 07-entry-strategies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/transform.rs
  - optimizer/src/entry_strategy.rs
autonomous: true

must_haves:
  truths:
    - "TransformGenerator has stack_ctxt field tracking component hierarchy"
    - "EntryPolicy trait accepts SegmentData instead of Segment"
    - "stack_ctxt is updated in all visitor methods matching SWC patterns"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "stack_ctxt field and push/pop in visitors"
      contains: "stack_ctxt: Vec<String>"
    - path: "optimizer/src/entry_strategy.rs"
      provides: "Updated EntryPolicy trait signature"
      contains: "segment: &SegmentData"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "optimizer/src/component/segment_data.rs"
      via: "SegmentData used in entry policy calls"
      pattern: "get_entry_for_sym.*stack_ctxt.*SegmentData"
---

<objective>
Add context stack infrastructure for entry strategy component grouping.

Purpose: PerComponentStrategy and SmartStrategy need to know the component hierarchy
to group segments correctly. The `stack_ctxt` tracks names as AST is traversed
(file name, function names, component names, JSX elements, attributes).

Output: TransformGenerator with stack_ctxt, EntryPolicy trait updated for SegmentData
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-entry-strategies/07-RESEARCH.md

# Key source files
@optimizer/src/transform.rs
@optimizer/src/entry_strategy.rs
@optimizer/src/component/segment_data.rs

# SWC reference for stack_ctxt patterns
@qwik-core/src/optimizer/core/src/transform.rs
@qwik-core/src/optimizer/core/src/entry_strategy.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stack_ctxt field and visitor updates to TransformGenerator</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add `stack_ctxt: Vec<String>` field to TransformGenerator struct.

Initialize in constructor: `stack_ctxt: Vec::with_capacity(16)`

Add push/pop in these visitor methods following SWC patterns:

1. **enter_variable_declarator / exit_variable_declarator**:
   - In enter: if `node.id` is BindingIdentifier, push its name
   - In exit: pop if pushed (track with bool flag)

2. **enter_function (for fn_decl)** - existing method needs update:
   - Before processing: if function has name (check via FunctionDecl), push function name
   - In exit_function: pop if pushed

3. **enter_class / exit_class**:
   - Push class name on enter, pop on exit

4. **enter_jsx_element / exit_jsx_element**:
   - Push element name (from JSXOpeningElement.name) on enter
   - Pop on exit

5. **enter_jsx_attribute** (existing) - already has some logic:
   - Ensure attribute name is pushed to stack_ctxt
   - Pop on exit

6. **enter_call_expression** (existing):
   - For marker function calls, push callee name
   - Pop in exit_call_expression

7. **Module level**: At start of transformation, push filename to stack_ctxt

Note: Some visitor methods already exist. Add stack_ctxt.push/pop at the right places.
Follow the pattern: track `stacked: bool` to know if we need to pop on exit.
  </action>
  <verify>cargo build --package qwik-optimizer 2>&1 | head -50</verify>
  <done>TransformGenerator has stack_ctxt field initialized and updated in all visitor methods matching SWC patterns</done>
</task>

<task type="auto">
  <name>Task 2: Update EntryPolicy trait signature to use SegmentData</name>
  <files>optimizer/src/entry_strategy.rs</files>
  <action>
Update the EntryPolicy trait signature from:
```rust
fn get_entry_for_sym(&self, context: &[String], segment: &Segment) -> Option<String>;
```

To:
```rust
fn get_entry_for_sym(&self, context: &[String], segment: &SegmentData) -> Option<String>;
```

Add import at top:
```rust
use crate::component::SegmentData;
```

Update all strategy implementations to use the new signature:

1. **InlineStrategy**: No change needed (ignores segment)
2. **SingleStrategy**: No change needed (ignores segment)
3. **PerSegmentStrategy**: No change needed (ignores segment)
4. **PerComponentStrategy**: Update signature, keep panic! for now (next plan implements)
5. **SmartStrategy**: Update signature, keep panic! for now (next plan implements)

The existing implementations only use `_segment` so just update the type annotation.
Remove the commented-out code in PerComponentStrategy and SmartStrategy (will be replaced in next plan).
  </action>
  <verify>cargo build --package qwik-optimizer 2>&1 | head -50</verify>
  <done>EntryPolicy trait and all implementations accept &SegmentData parameter</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for stack_ctxt tracking</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add tests in the `#[cfg(test)]` module of transform.rs to verify stack_ctxt tracking.

Create a test helper that transforms code and captures the stack_ctxt state at QRL extraction.

Test cases:
1. **test_stack_ctxt_component_function**: Verify component function name is in context
   - Input: `const Counter = component$(() => { ... })`
   - Verify: stack_ctxt contains "Counter" when QRL is processed

2. **test_stack_ctxt_jsx_element**: Verify JSX element names are tracked
   - Input: JSX with `<div onClick$={() => {}}>`
   - Verify: stack_ctxt includes element name when processing event handler

3. **test_stack_ctxt_nested**: Verify nested components build correct hierarchy
   - Input: `const App = component$(() => { const Inner = component$(() => {}); })`
   - Verify: Inner's QRL has both App and Inner in context

Since we can't directly inspect stack_ctxt during transformation, test indirectly via
the display_name generation which uses the segment stack (related but different).
Add a debug println! or use a RefCell to capture stack_ctxt for testing.

Alternative: Add a method `pub fn current_context(&self) -> &[String]` that returns
stack_ctxt slice for testing purposes.
  </action>
  <verify>cargo test --package qwik-optimizer stack_ctxt 2>&1 | tail -30</verify>
  <done>Unit tests verify stack_ctxt tracking works for components, JSX elements, and nested structures</done>
</task>

</tasks>

<verification>
1. `cargo build --package qwik-optimizer` compiles without errors
2. `cargo test --package qwik-optimizer` - all existing tests pass
3. New stack_ctxt tests pass
4. EntryPolicy trait signature updated to use SegmentData
</verification>

<success_criteria>
- TransformGenerator has stack_ctxt: Vec<String> field
- stack_ctxt initialized with capacity 16 in constructor
- push/pop added in: variable_declarator, fn_decl, class_decl, jsx_element, jsx_attr, call_expr, module
- EntryPolicy::get_entry_for_sym takes &SegmentData instead of &Segment
- All strategy implementations compile with new signature
- Existing 148 tests pass
- New stack_ctxt tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-entry-strategies/07-01-SUMMARY.md`
</output>
