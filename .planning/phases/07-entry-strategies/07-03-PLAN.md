---
phase: 07-entry-strategies
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - optimizer/src/transform.rs
  - optimizer/src/component/component.rs
  - optimizer/src/js_lib_interface.rs
autonomous: true

must_haves:
  truths:
    - "Entry strategy is wired from TransformOptions to segment generation"
    - "SegmentAnalysis.entry field is populated based on strategy"
    - "Integration tests verify all strategies produce correct output"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Entry policy integration with segment creation"
      contains: "entry_policy.get_entry_for_sym"
    - path: "optimizer/src/component/component.rs"
      provides: "QrlComponent with entry field"
      contains: "pub entry: Option<String>"
    - path: "optimizer/src/js_lib_interface.rs"
      provides: "Entry field populated in SegmentAnalysis"
      contains: "entry:"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "optimizer/src/entry_strategy.rs"
      via: "Calls get_entry_for_sym during QRL extraction"
      pattern: "get_entry_for_sym.*stack_ctxt"
    - from: "optimizer/src/js_lib_interface.rs"
      to: "optimizer/src/transform.rs"
      via: "Receives entry value from transformation"
      pattern: "segment.*entry"
---

<objective>
Wire entry strategy to segment analysis and verify all strategies work end-to-end.

Purpose: Complete the entry strategy feature by connecting the strategy selection
to actual segment generation. The entry field in SegmentAnalysis tells the bundler
how to group segment files.

Output: Working entry strategy integration with comprehensive tests
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-entry-strategies/07-RESEARCH.md
@.planning/phases/07-entry-strategies/07-01-SUMMARY.md
@.planning/phases/07-entry-strategies/07-02-SUMMARY.md

# Implementation files
@optimizer/src/transform.rs
@optimizer/src/js_lib_interface.rs
@optimizer/src/entry_strategy.rs
@optimizer/src/component/component.rs

# SWC reference for wiring
@qwik-core/src/optimizer/core/src/transform.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add entry_policy to TransformGenerator and wire to segment creation</name>
  <files>optimizer/src/transform.rs, optimizer/src/component/component.rs</files>
  <action>
Add entry_policy field to TransformGenerator and call it during segment creation.

1. Add field to TransformGenerator struct:
```rust
/// Entry policy for determining how segments are grouped for bundling.
entry_policy: Box<dyn EntryPolicy>,
```

2. Update TransformGenerator::new() to accept entry_policy parameter:
- Add parameter: `entry_policy: Box<dyn EntryPolicy>`
- Initialize field: `entry_policy,`
- **Location**: TransformGenerator::new() is called from `optimize_module()` in transform.rs (around line 50-80). Update that call site to pass entry_policy.

3. Add imports at top if not present:
```rust
use crate::entry_strategy::{EntryPolicy, parse_entry_strategy};
```

4. **QrlComponent creation location**: QrlComponent is created in the `create_qrl_component` method in transform.rs (search for `QrlComponent::new` or `QrlComponent {`). When creating a QrlComponent, call entry_policy to get the entry value:
```rust
let entry = self.entry_policy.get_entry_for_sym(&self.stack_ctxt, &segment_data);
```

5. **REQUIRED: Add entry field to QrlComponent struct in optimizer/src/component/component.rs:**
```rust
pub struct QrlComponent {
    // ... existing fields ...
    /// Entry grouping for bundler (determined by entry strategy)
    pub entry: Option<String>,
}
```

Update QrlComponent::new() to accept and store entry parameter:
```rust
pub fn new(
    // ... existing params ...
    entry: Option<String>,
) -> Self {
    Self {
        // ... existing fields ...
        entry,
    }
}
```

6. Update all callers of QrlComponent::new() to pass the entry value.

7. Update callers of TransformGenerator::new():
- **Primary call site**: `optimize_module()` function in transform.rs
- Pass the entry_policy parsed from TransformOptions

Check TransformOptions in js_lib_interface.rs - it already has entry_strategy field.
Parse it with parse_entry_strategy() to get the Box<dyn EntryPolicy>.
  </action>
  <verify>cargo build --package qwik-optimizer 2>&1 | head -50</verify>
  <done>entry_policy field added to TransformGenerator, entry field added to QrlComponent struct, called during segment creation</done>
</task>

<task type="auto">
  <name>Task 2: Populate entry field in SegmentAnalysis</name>
  <files>optimizer/src/js_lib_interface.rs</files>
  <action>
Ensure the entry field flows from QrlComponent to SegmentAnalysis in the output.

1. Check SegmentAnalysis struct - it already has `entry: Option<String>` field.

2. Find where SegmentAnalysis is created (around line 276-285):
```rust
segment: Some(SegmentAnalysis {
    origin: relative_path.clone(),
    name: c.id.symbol_name.clone(),
    entry: None,  // <-- This needs to come from QrlComponent
    ...
})
```

3. Update to use the entry value from QrlComponent:
```rust
entry: c.entry.clone(),
```

4. Ensure QrlComponent struct has the entry field (done in Task 1):
- The entry field was added in Task 1: `pub entry: Option<String>`
- QrlComponent creation includes entry value from entry_policy

5. If TransformOptions needs to be passed through more layers:
- Check optimize_module() function signature
- Ensure entry_strategy from TransformFsModuleInput flows to TransformGenerator
  </action>
  <verify>cargo build --package qwik-optimizer 2>&1 | head -50</verify>
  <done>SegmentAnalysis.entry is populated from QrlComponent.entry value</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for entry strategies</name>
  <files>optimizer/src/js_lib_interface.rs</files>
  <action>
Add integration tests that verify each entry strategy produces correct output.

Add tests in the existing `#[cfg(test)]` module of js_lib_interface.rs:

```rust
#[test]
fn test_entry_strategy_inline() {
    // Test that InlineStrategy groups all segments
    let input = TransformFsModuleInput {
        path: PathBuf::from("test.tsx"),
        src_dir: ".".to_string(),
        root_dir: None,
        minify: MinifyMode::None,
        entry_strategy: EntryStrategy::Inline,
        source_maps: false,
        transpile_ts: true,
        transpile_jsx: true,
        preserve_filenames: false,
        explicit_extensions: false,
        scope: None,
    };
    let code = r#"
        import { component$ } from "@qwik.dev/core";
        export const Counter = component$(() => {
            return <button onClick$={() => console.log("click")}>Click</button>;
        });
    "#;

    let result = transform_fs_module(&input, code);
    // Verify all segments have entry = Some("entry_segments")
    for output in result.modules {
        if let Some(segment) = output.segment {
            assert_eq!(segment.entry, Some("entry_segments".to_string()));
        }
    }
}

#[test]
fn test_entry_strategy_segment() {
    // Test that PerSegmentStrategy creates separate files
    let input = TransformFsModuleInput {
        entry_strategy: EntryStrategy::Segment,
        // ... other fields
    };
    let code = /* same as above */;

    let result = transform_fs_module(&input, code);
    // Verify all segments have entry = None (separate files)
    for output in result.modules {
        if let Some(segment) = output.segment {
            assert_eq!(segment.entry, None);
        }
    }
}

#[test]
fn test_entry_strategy_component() {
    // Test that PerComponentStrategy groups by component
    let input = TransformFsModuleInput {
        entry_strategy: EntryStrategy::Component,
        // ...
    };
    let code = /* component with multiple QRLs */;

    let result = transform_fs_module(&input, code);
    // Verify segments have entry = Some("{origin}_entry_{component}")
    for output in result.modules {
        if let Some(segment) = output.segment {
            assert!(segment.entry.is_some());
            assert!(segment.entry.as_ref().unwrap().contains("_entry_"));
        }
    }
}

#[test]
fn test_entry_strategy_smart() {
    // Test SmartStrategy separates stateless handlers
    let input = TransformFsModuleInput {
        entry_strategy: EntryStrategy::Smart,
        // ...
    };

    // Code with both capturing and non-capturing handlers
    let code = r#"
        import { component$ } from "@qwik.dev/core";
        export const Counter = component$(() => {
            const count = 0;
            return (
                <div>
                    <button onClick$={() => console.log("no capture")}>A</button>
                    <button onClick$={() => console.log(count)}>B</button>
                </div>
            );
        });
    "#;

    let result = transform_fs_module(&input, code);
    // Non-capturing handler should have entry = None
    // Capturing handler should have entry = Some(...)
    // (Verify based on segment characteristics)
}
```

Adapt tests to actual API. The key is verifying:
1. InlineStrategy: all entry = Some("entry_segments")
2. PerSegmentStrategy: all entry = None
3. PerComponentStrategy: entry = Some("{origin}_entry_{component}")
4. SmartStrategy: stateless handlers entry = None, others grouped
  </action>
  <verify>cargo test --package qwik-optimizer test_entry_strategy 2>&1 | tail -50</verify>
  <done>Integration tests verify all entry strategies produce correct segment grouping; entry values are non-None where expected (InlineStrategy, PerComponentStrategy with grouping, SmartStrategy for capturing handlers)</done>
</task>

</tasks>

<verification>
1. `cargo build --package qwik-optimizer` compiles without errors
2. `cargo test --package qwik-optimizer` - all tests pass (150+)
3. Integration tests verify:
   - InlineStrategy groups all to "entry_segments"
   - SingleStrategy groups all to "entry_segments"
   - PerSegmentStrategy produces separate files (None)
   - PerComponentStrategy groups by component name
   - SmartStrategy optimizes based on captures
</verification>

<success_criteria>
- entry_policy field added to TransformGenerator
- entry field added to QrlComponent struct with pub entry: Option<String>
- Entry value flows: TransformOptions -> TransformGenerator -> QrlComponent -> SegmentAnalysis
- SegmentAnalysis.entry populated correctly for each strategy
- 4+ integration tests pass verifying all strategy behaviors
- All existing tests pass (148+)
- Requirements ENT-01 through ENT-05 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/07-entry-strategies/07-03-SUMMARY.md`
</output>
