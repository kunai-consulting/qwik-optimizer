---
phase: 09-typescript-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/transform.rs
autonomous: true

must_haves:
  truths:
    - "Type-only import declarations are not tracked for QRL capture"
    - "Type-only import specifiers within mixed imports are not tracked"
    - "Value imports continue to be tracked correctly"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "Import collection with type-only filtering"
      contains: "import_kind.is_type()"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "ImportTracker"
      via: "Filtered import collection loop"
      pattern: "import_kind\\.is_type\\(\\)"
---

<objective>
Filter type-only imports from QRL capture tracking

Purpose: Type-only imports (`import type { Foo }` and `import { type Foo }`) don't exist at runtime. If captured in QRL arrays, they cause runtime errors. This plan adds filtering to exclude type-only imports from the ImportTracker.

Output: Updated import collection loop in transform.rs that skips type-only imports
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-typescript-support/09-RESEARCH.md

@optimizer/src/transform.rs (lines 2880-2905 - import collection loop)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Filter type-only imports in collection loop</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Update the import collection loop (lines 2880-2905) to filter out type-only imports:

1. Before iterating specifiers, check if the entire import declaration is type-only:
   ```rust
   if import.import_kind.is_type() {
       continue;  // Skip entire type-only import: `import type { Foo } from '...'`
   }
   ```

2. Inside the ImportSpecifier match arm, check if the individual specifier is type-only:
   ```rust
   ImportDeclarationSpecifier::ImportSpecifier(spec) => {
       // Skip type-only specifiers: `import { type Foo, bar } from '...'`
       if spec.import_kind.is_type() {
           continue;
       }
       let imported = spec.imported.name().to_string();
       let local = spec.local.name.to_string();
       import_tracker.add_import(&source, &imported, &local);
   }
   ```

Note: ImportDefaultSpecifier and ImportNamespaceSpecifier cannot be type-only at the specifier level (TypeScript doesn't support `import type default` syntax), so those branches remain unchanged.

The ImportOrExportKind enum and is_type() method are already imported via `oxc_ast::ast::ImportOrExportKind` (verify this import exists, add if needed).
  </action>
  <verify>
Run `~/.cargo/bin/cargo build` - compiles without errors
Run `~/.cargo/bin/cargo test --lib` - all 202 existing tests pass
  </verify>
  <done>
Import collection loop filters out type-only imports at both declaration and specifier levels. Existing tests continue to pass (no regressions).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for type-only import filtering</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add unit tests to the `mod tests` section at the bottom of transform.rs:

1. Test type-only import declaration is not tracked:
   ```rust
   #[test]
   fn test_type_only_import_declaration_not_tracked() {
       // Test that `import type { Component } from '@qwik.dev/core'` is not captured
       // Use transform() and verify the ImportTracker doesn't contain type imports
   }
   ```

2. Test mixed import with type specifier:
   ```rust
   #[test]
   fn test_mixed_import_type_specifier_not_tracked() {
       // Test that `import { type Signal, $ } from '@qwik.dev/core'`
       // - Signal (type-only) is NOT tracked
       // - $ (value) IS tracked
   }
   ```

3. Test value imports still tracked correctly:
   ```rust
   #[test]
   fn test_value_imports_still_tracked() {
       // Test that regular `import { component$ } from '@qwik.dev/core'` is tracked
   }
   ```

Since ImportTracker is internal to transform(), create integration tests that verify the behavior through the transform output. A type-only import should NOT appear in generated segment imports or capture arrays.

Test input pattern:
```typescript
import type { Component } from '@qwik.dev/core';
import { type Signal, component$ } from '@qwik.dev/core';

export const App = component$(() => {
  return <div>Hello</div>;
});
```

Expected: No reference to Component or Signal in output (they're type-only).
  </action>
  <verify>
Run `~/.cargo/bin/cargo test --lib test_type` - new tests pass
Run `~/.cargo/bin/cargo test --lib` - all tests pass (202 + new tests)
  </verify>
  <done>
At least 3 unit tests added verifying type-only import filtering behavior. Tests demonstrate that type-only imports are excluded from tracking while value imports continue to work.
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
~/.cargo/bin/cargo build

# All tests pass
~/.cargo/bin/cargo test --lib

# Verify new tests exist and pass
~/.cargo/bin/cargo test --lib test_type
```
</verification>

<success_criteria>
- Import collection loop checks import_kind.is_type() at declaration level
- Import collection loop checks import_kind.is_type() at specifier level
- Type-only imports are NOT added to ImportTracker
- Value imports continue to be tracked correctly
- All 202+ tests pass (no regressions)
- New tests verify type-only filtering behavior
</success_criteria>

<output>
After completion, create `.planning/phases/09-typescript-support/09-01-SUMMARY.md`
</output>
