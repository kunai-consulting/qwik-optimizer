---
phase: 09-typescript-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - optimizer/src/transform.rs
autonomous: true

must_haves:
  truths:
    - "TSX files parse and transform without errors"
    - "Type annotations are stripped from output"
    - "Generic component types work correctly"
  artifacts:
    - path: "optimizer/src/transform.rs"
      provides: "TypeScript integration tests"
      contains: "tsx"
  key_links:
    - from: "optimizer/src/transform.rs"
      to: "TypeScriptOptions"
      via: "transpile_ts transform path"
      pattern: "transpile_ts"
---

<objective>
Add comprehensive TypeScript and TSX transformation tests

Purpose: Verify that the existing TypeScript infrastructure (TSX parsing via SourceType::tsx(), type stripping via oxc_transformer) works correctly for all TypeScript patterns used in Qwik applications. The infrastructure exists but lacks test coverage.

Output: Comprehensive test suite validating TypeScript support
</objective>

<execution_context>
@/Users/jackshelton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jackshelton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-typescript-support/09-RESEARCH.md

@optimizer/src/transform.rs (TypeScript transform at lines 2862-2878)
@optimizer/src/component/language.rs (SourceType::tsx() handling)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TSX parsing and transformation tests</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add tests to the `mod tests` section verifying TSX files work correctly:

1. Test basic TSX parsing with type annotations:
   ```rust
   #[test]
   fn test_tsx_type_annotations_stripped() {
       // Input: TSX with explicit type annotations
       // const comp: Component = component$(() => <div />);
       // function foo(props: Props): JSX.Element { return <div />; }
       // Expected: Types stripped, transformation works
   }
   ```

2. Test generic component types:
   ```rust
   #[test]
   fn test_tsx_generic_component() {
       // Input: Component<MyProps> generic usage
       // export const App: Component<Props> = component$(() => <div>{props.name}</div>);
       // Expected: Generic stripped, component transforms correctly
   }
   ```

3. Test interface/type declarations don't break transform:
   ```rust
   #[test]
   fn test_tsx_interface_declarations() {
       // Input: interface Props { name: string; }
       // export const App = component$<Props>(() => <div />);
       // Expected: Interface stripped, transform works
   }
   ```

4. Test type assertions:
   ```rust
   #[test]
   fn test_tsx_type_assertions() {
       // Input: (foo as string), foo satisfies Type
       // Expected: Assertions stripped
   }
   ```

For each test:
- Use `.tsx` extension in source path
- Set `transpile_ts: true` in TransformOptions
- Verify output has NO type annotations
- Verify QRL transformation still works
  </action>
  <verify>
Run `~/.cargo/bin/cargo test --lib test_tsx` - new tests pass
Run `~/.cargo/bin/cargo test --lib` - all tests pass
  </verify>
  <done>
At least 4 tests added covering TSX parsing and type annotation stripping. Tests verify that TypeScript features don't break the optimizer and types are correctly removed from output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add QRL capture with TypeScript tests</name>
  <files>optimizer/src/transform.rs</files>
  <action>
Add tests verifying QRL capture works correctly with TypeScript patterns:

1. Test typed function parameters in QRL:
   ```rust
   #[test]
   fn test_qrl_typed_parameters() {
       // Input: $(() => { const fn = (x: number): string => x.toString(); })
       // Expected: Types stripped, QRL extracts correctly
   }
   ```

2. Test captured typed variables:
   ```rust
   #[test]
   fn test_qrl_capture_typed_variables() {
       // Input:
       // const count: Signal<number> = useSignal(0);
       // $(() => console.log(count.value));
       // Expected: count captured correctly, type annotation stripped
   }
   ```

3. Test as const assertions:
   ```rust
   #[test]
   fn test_qrl_as_const() {
       // Input: const config = { key: 'value' } as const;
       // Expected: as const stripped, value works
   }
   ```

Verify for each test:
- QRL extraction works (segments generated)
- Captured variables correct (scoped_idents populated)
- Output has no TypeScript syntax
  </action>
  <verify>
Run `~/.cargo/bin/cargo test --lib test_qrl_typed` - new tests pass
Run `~/.cargo/bin/cargo test --lib` - all tests pass
  </verify>
  <done>
At least 3 tests added covering QRL behavior with TypeScript patterns. Tests verify that typed code transforms correctly and captures work with typed variables.
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
~/.cargo/bin/cargo build

# All tests pass
~/.cargo/bin/cargo test --lib

# Verify new TypeScript tests pass
~/.cargo/bin/cargo test --lib test_tsx
~/.cargo/bin/cargo test --lib test_qrl_typed
```
</verification>

<success_criteria>
- TSX files parse without errors
- Type annotations stripped from output
- Generic component types transform correctly
- Interface/type declarations don't break transform
- QRL capture works with typed variables
- Type assertions stripped correctly
- All tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/09-typescript-support/09-02-SUMMARY.md`
</output>
